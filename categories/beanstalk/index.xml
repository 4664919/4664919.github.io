<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Beanstalk on simons blog</title>
    <link>http://blog.simonsun.net/categories/beanstalk/</link>
    <description>Recent content in Beanstalk on simons blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.simonsun.net/categories/beanstalk/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>beanstalk使用介绍</title>
      <link>http://blog.simonsun.net/architecture_how_to_use_beanstalk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.simonsun.net/architecture_how_to_use_beanstalk/</guid>
      <description>

&lt;h3 id=&#34;使用beanstalk也有二年了-之前对项目的beanstalk进行封装-php版本-golang两个版本-这里纪录一个日志权当说明文档来用了-div:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;使用beanstalk也有二年了，之前对项目的beanstalk进行封装(php版本、GoLang两个版本)，这里纪录一个日志权当说明文档来用了&lt;/div&gt;&lt;/h3&gt;

&lt;h4 id=&#34;beanstalk功能描述:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;beanstalk功能描述：&lt;/h4&gt;

&lt;p&gt;beanstalk是一个异步的队列服务，目标是把复杂、耗时的任务放到后端去执行。提升前端响应时间。确切的说这里说的前端、后端 就是beanstalk的producer-consumer，一个负责生产，一个负责消费&lt;/p&gt;

&lt;h4 id=&#34;使用中发现的优缺点:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;使用中发现的优缺点：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对于小的队列应用场景，使用beanstalk可以很方便快速的使用&lt;/li&gt;
&lt;li&gt;不支持分布式&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据只有一份&lt;/p&gt;

&lt;h4 id=&#34;使用中未解决的问题:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;使用中未解决的问题：&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发现beanstalk在使用中，在量稍微大一些的时候，经常假死：“有任务，但是取不到任务” 这个问题在GoLang、PHP中均存在&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;业务实例:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;业务实例：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;比如发邮件、短信等。可以直接丢入队列，然后服务端去依次发送&lt;/li&gt;
&lt;li&gt;比如电商中的业务、行为分析等操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;具体使用方式:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;具体使用方式：&lt;/h4&gt;

&lt;p&gt;一个任务的典型生命流程很简单：
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;null&#34;&gt;
put （丢任务，生产者）  reserve（取任务，消费者）        delete（删除）
-&amp;gt; [READY]beanstalk的状态-&amp;gt; [RESERVED]beanstalk的状态—&amp;gt; 生命周期完成
&lt;/pre&gt;
    producer中创建任务，put后producer生命周期就结束了
    &lt;br&gt;
    consumer负责干活。一般取出任务后删除即可。取出任务之前是ready状态。取出任务后就reserve状态。删除后任务就清掉了。&lt;/p&gt;

&lt;h4 id=&#34;完整的生命周期:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;完整的生命周期:&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.simonsun.net/wp-content/uploads/2015/05/0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A.png&#34;&gt;&lt;img src=&#34;http://dev.blog.simonsun.net/wp-content/uploads/2015/05/0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A.png&#34; alt=&#34;0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A&#34; /&gt;&lt;/a&gt;
{{ % img src=&amp;ldquo;/upload/beanstalk_life.png&amp;rdquo; alt=&amp;ldquo;beanstalk完整的生命周期&amp;rdquo; %}}&lt;/p&gt;

&lt;p&gt;Beanstalkd中完整的任务的生命周期。一个job有READY, RESERVED, DELAYED, BURIED四种状态。
&lt;br&gt;
当producer直接put一个job时，job就处于READY状态，等待consumer来处理，如果选择延迟 put，job就先到DELAYED状态，等待时间过后才迁移到READY状态。
&lt;br&gt;
&lt;code&gt;consumer&lt;/code&gt;获取了当前READY的job后，该job的状态就迁移 到RESERVED，这样其他的consumer就不能再操作该job。
&lt;br&gt;
当consumer完成该job后，可以选择delete, release或者bury操作;
&lt;br&gt;
delete之后，job从系统消亡，之后不能再获取;
&lt;br&gt;
release操作可以重新把该job状态迁移回READY(也 可以延迟该状态迁移操作)，使其他的consumer可以继续获取和执行该job;
&lt;br&gt;
有意思的是bury操作，可以把该job休眠，等到需要的时候，再将休 眠的job kick回READY状态，也可以delete BURIED状态的job。
&lt;br&gt;
正是有这些有趣的操作和状态，才可以基于此做出很多意思的应用，比如要实现一个循环队列，就可以将RESERVED状态的 job休眠掉，等没有READY状态的job时再将BURIED状态的job一次性kick回READY状态。&lt;/p&gt;

&lt;h4 id=&#34;任务的状态:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;任务的状态：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ready     等待状态，任务在等待consumer执行&lt;/li&gt;
&lt;li&gt;reserved     任务准备状态，当任务从tube中取出来（包括准备取出来）时，这个任务就是reserved状态，其他consumer将取不到此任务&lt;/li&gt;
&lt;li&gt;delayed      延时状态，任务在指定时间之后才会变为ready状态&lt;/li&gt;
&lt;li&gt;buried       等待kick，通常是任务失败为此状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;参数说明:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;参数说明：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;pri &amp;#8211; priority(优先级) － 支持0到2**32的优先级，值越小，优先级越高，默认优先级为1024。&lt;/li&gt;
&lt;li&gt;ttr &amp;#8211; time to run(任务执行时间) － 允许consumer执行这个任务的时间&lt;/li&gt;
&lt;li&gt;delay － 定时执行的时间，秒为单位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;命令列表:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;命令列表：&lt;/h4&gt;

&lt;p&gt;生产者使用命令
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;put
写入一个任务
     $ put &lt;pri&gt; &lt;delay&gt; &lt;ttr&gt; &lt;bytes&gt;\r\n
&lt;data&gt;\r\n&lt;/p&gt;

&lt;h4 id=&#34;other-commands:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;－－Other Commands－－&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;peek&lt;/li&gt;
&lt;li&gt;kick&lt;/li&gt;
&lt;li&gt;kick-job&lt;/li&gt;
&lt;li&gt;stats-job&lt;/li&gt;
&lt;li&gt;stats-tube&lt;/li&gt;
&lt;li&gt;stats&lt;/li&gt;
&lt;li&gt;list-tubes&lt;/li&gt;
&lt;li&gt;list-tube-used&lt;/li&gt;
&lt;li&gt;list-tubes-watched&lt;/li&gt;
&lt;li&gt;quit&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>