<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>架构 on simons blog</title>
    <link>http://blog.simonsun.net/categories/%E6%9E%B6%E6%9E%84/</link>
    <description>Recent content in 架构 on simons blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.simonsun.net/categories/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>golang日志系统架构设计</title>
      <link>http://blog.simonsun.net/logv3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.simonsun.net/logv3/</guid>
      <description>

&lt;p&gt;#[名言] 不断的重构，模块会越来越壮大，功能会越来越多，代码会复杂，这时候开始重构。&lt;/p&gt;

&lt;h3 id=&#34;为啥鞋日志包:7fd877a2562cbb7976f27484b36083fa&#34;&gt;为啥鞋日志包&lt;/h3&gt;

&lt;p&gt;日志是debug不可或缺的模块，当出现问题时可以追踪问题、查看异常原因。作为后端服务，需要能够回溯问题并告知使用服务的同学问题出在哪里。
目前还未发现比较健壮、并且适用本地服务的开源日志包，所以只能自己动手。&lt;/p&gt;

&lt;h3 id=&#34;日志包的使用臆测:7fd877a2562cbb7976f27484b36083fa&#34;&gt;日志包的使用臆测&lt;/h3&gt;

&lt;p&gt;可以不初始化 - 单元测试、无需日志的时候，可以直接使用。
可以支持并发日志。－日志按块写入，根据pkid查看整个生命周期
可以不同端输出。－ 日志可以同时写入文件、控制台
可以多文件存储。－ 日志根据业务[组]写入不同的文件中&lt;/p&gt;

&lt;p&gt;我们会收到使用服务的同学的各种问题&lt;/p&gt;

&lt;h3 id=&#34;v3版本日志功能:7fd877a2562cbb7976f27484b36083fa&#34;&gt;v3版本日志功能：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;支持并发写入

&lt;ul&gt;
&lt;li&gt;块级写入&lt;/li&gt;
&lt;li&gt;原子操作ID&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多分组输出

&lt;ul&gt;
&lt;li&gt;按名字分别写入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多种输出方式

&lt;ul&gt;
&lt;li&gt;console - stdout&lt;/li&gt;
&lt;li&gt;file&lt;/li&gt;
&lt;li&gt;queue 队列输出&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;打印文件名，行号&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;日志与内置log-beego-log的区别:7fd877a2562cbb7976f27484b36083fa&#34;&gt;日志与内置log、BeeGo log的区别&lt;/h3&gt;

&lt;p&gt;使用为了简单，快速开发，以及更好的兼容本地服务。
log可以多文件存储，但是多种输出方式得封装
BeeGo可以多种输出方式，但是文件只能一个&lt;/p&gt;

&lt;p&gt;使用方式[简单版]:&lt;br /&gt;
var log *logv3.Logger = logv3.NewLog(nil)
log.Debug(&amp;ldquo;log debug&amp;rdquo;,1,2,&amp;ldquo;content&amp;rdquo;)
log.Error(&amp;ldquo;faild&amp;rdquo;)
输出到console：
[2015-10-22 11:33:22,debug] log debug 1 2 content
[2015-10-22 11:33:22,info] faild
[2015-10-22 11:33:22,debug] faild
[2015-10-22 11:33:22,error] faild&lt;/p&gt;

&lt;p&gt;使用方式:&lt;br /&gt;
//创建日志配置
var log_struct *logv3.LogStruct = &amp;amp;logv3.LogStruct{
    OpenFileLine : false,
    FileStruct:&amp;amp;logv3.FileStruct{
        LogPath:&amp;ldquo;/tmp/testlog/&amp;rdquo;,
        LogName:&amp;ldquo;log&amp;rdquo;,
    },
    ConsoleStruct:&amp;amp;logv3.ConsoleStruct{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
//创建一个logger
var log *logv3.Logger = logv3.NewLog(log_struct)
//创建一个分组
var group1 *logv3.Group  = log.NewGroup(&amp;ldquo;group_name1&amp;rdquo;)
group1.Debug(&amp;ldquo;log_debug1&amp;rdquo;)
//创建一个分组
var group2 *logv3.Group  = log.NewGroup(&amp;ldquo;group_name2&amp;rdquo;)
group2.Debug(&amp;ldquo;log_debug2&amp;rdquo;)
//原log可以继续使用
log.Debug(&amp;ldquo;log_debug0&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;会输出到console，并且写入文件
[2015-10-22 11:33:22,0,debug] log_debug1
[2015-10-22 11:33:22,0,debug] log_debug2
[2015-10-22 11:33:22,0,debug] log_debug0&lt;/p&gt;

&lt;p&gt;文件：/tmp/testlog/log-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,0,debug] log_debug0&lt;/p&gt;

&lt;p&gt;文件：/tmp/testlog/group_name1-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,1,debug] log_debug1&lt;/p&gt;

&lt;p&gt;文件：/tmp/testlog/group_name2-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,2,debug] log_debug2&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>