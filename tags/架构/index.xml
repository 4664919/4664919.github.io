<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>架构 on simons blog</title>
    <link>http://blog.simonsun.net/tags/%E6%9E%B6%E6%9E%84/</link>
    <description>Recent content in 架构 on simons blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.simonsun.net/tags/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>beanstalk使用介绍</title>
      <link>http://blog.simonsun.net/architecture_how_to_use_beanstalk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.simonsun.net/architecture_how_to_use_beanstalk/</guid>
      <description>

&lt;h3 id=&#34;使用beanstalk也有二年了-之前对项目的beanstalk进行封装-php版本-golang两个版本-这里纪录一个日志权当说明文档来用了-div:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;使用beanstalk也有二年了，之前对项目的beanstalk进行封装(php版本、GoLang两个版本)，这里纪录一个日志权当说明文档来用了&lt;/div&gt;&lt;/h3&gt;

&lt;h4 id=&#34;beanstalk功能描述:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;beanstalk功能描述：&lt;/h4&gt;

&lt;p&gt;beanstalk是一个异步的队列服务，目标是把复杂、耗时的任务放到后端去执行。提升前端响应时间。确切的说这里说的前端、后端 就是beanstalk的producer-consumer，一个负责生产，一个负责消费&lt;/p&gt;

&lt;h4 id=&#34;使用中发现的优缺点:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;使用中发现的优缺点：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对于小的队列应用场景，使用beanstalk可以很方便快速的使用&lt;/li&gt;
&lt;li&gt;不支持分布式&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据只有一份&lt;/p&gt;

&lt;h4 id=&#34;使用中未解决的问题:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;使用中未解决的问题：&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发现beanstalk在使用中，在量稍微大一些的时候，经常假死：“有任务，但是取不到任务” 这个问题在GoLang、PHP中均存在&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;业务实例:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;业务实例：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;比如发邮件、短信等。可以直接丢入队列，然后服务端去依次发送&lt;/li&gt;
&lt;li&gt;比如电商中的业务、行为分析等操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;具体使用方式:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;具体使用方式：&lt;/h4&gt;

&lt;p&gt;一个任务的典型生命流程很简单：
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;null&#34;&gt;
put （丢任务，生产者）  reserve（取任务，消费者）        delete（删除）
-&amp;gt; [READY]beanstalk的状态-&amp;gt; [RESERVED]beanstalk的状态—&amp;gt; 生命周期完成
&lt;/pre&gt;
    producer中创建任务，put后producer生命周期就结束了
    &lt;br&gt;
    consumer负责干活。一般取出任务后删除即可。取出任务之前是ready状态。取出任务后就reserve状态。删除后任务就清掉了。&lt;/p&gt;

&lt;h4 id=&#34;完整的生命周期:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;完整的生命周期:&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.simonsun.net/wp-content/uploads/2015/05/0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A.png&#34;&gt;&lt;img src=&#34;http://dev.blog.simonsun.net/wp-content/uploads/2015/05/0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A.png&#34; alt=&#34;0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A&#34; /&gt;&lt;/a&gt;
{{ % img src=&amp;ldquo;/upload/beanstalk_life.png&amp;rdquo; alt=&amp;ldquo;beanstalk完整的生命周期&amp;rdquo; %}}&lt;/p&gt;

&lt;p&gt;Beanstalkd中完整的任务的生命周期。一个job有READY, RESERVED, DELAYED, BURIED四种状态。
&lt;br&gt;
当producer直接put一个job时，job就处于READY状态，等待consumer来处理，如果选择延迟 put，job就先到DELAYED状态，等待时间过后才迁移到READY状态。
&lt;br&gt;
&lt;code&gt;consumer&lt;/code&gt;获取了当前READY的job后，该job的状态就迁移 到RESERVED，这样其他的consumer就不能再操作该job。
&lt;br&gt;
当consumer完成该job后，可以选择delete, release或者bury操作;
&lt;br&gt;
delete之后，job从系统消亡，之后不能再获取;
&lt;br&gt;
release操作可以重新把该job状态迁移回READY(也 可以延迟该状态迁移操作)，使其他的consumer可以继续获取和执行该job;
&lt;br&gt;
有意思的是bury操作，可以把该job休眠，等到需要的时候，再将休 眠的job kick回READY状态，也可以delete BURIED状态的job。
&lt;br&gt;
正是有这些有趣的操作和状态，才可以基于此做出很多意思的应用，比如要实现一个循环队列，就可以将RESERVED状态的 job休眠掉，等没有READY状态的job时再将BURIED状态的job一次性kick回READY状态。&lt;/p&gt;

&lt;h4 id=&#34;任务的状态:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;任务的状态：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ready     等待状态，任务在等待consumer执行&lt;/li&gt;
&lt;li&gt;reserved     任务准备状态，当任务从tube中取出来（包括准备取出来）时，这个任务就是reserved状态，其他consumer将取不到此任务&lt;/li&gt;
&lt;li&gt;delayed      延时状态，任务在指定时间之后才会变为ready状态&lt;/li&gt;
&lt;li&gt;buried       等待kick，通常是任务失败为此状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;参数说明:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;参数说明：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;pri &amp;#8211; priority(优先级) － 支持0到2**32的优先级，值越小，优先级越高，默认优先级为1024。&lt;/li&gt;
&lt;li&gt;ttr &amp;#8211; time to run(任务执行时间) － 允许consumer执行这个任务的时间&lt;/li&gt;
&lt;li&gt;delay － 定时执行的时间，秒为单位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;命令列表:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;命令列表：&lt;/h4&gt;

&lt;p&gt;生产者使用命令
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;put
写入一个任务
     $ put &lt;pri&gt; &lt;delay&gt; &lt;ttr&gt; &lt;bytes&gt;\r\n
&lt;data&gt;\r\n&lt;/p&gt;

&lt;h4 id=&#34;other-commands:1b0a41cc7d2fc25b18368e05c17b19c8&#34;&gt;－－Other Commands－－&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;peek&lt;/li&gt;
&lt;li&gt;kick&lt;/li&gt;
&lt;li&gt;kick-job&lt;/li&gt;
&lt;li&gt;stats-job&lt;/li&gt;
&lt;li&gt;stats-tube&lt;/li&gt;
&lt;li&gt;stats&lt;/li&gt;
&lt;li&gt;list-tubes&lt;/li&gt;
&lt;li&gt;list-tube-used&lt;/li&gt;
&lt;li&gt;list-tubes-watched&lt;/li&gt;
&lt;li&gt;quit&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>golang日志系统架构设计</title>
      <link>http://blog.simonsun.net/logv3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.simonsun.net/logv3/</guid>
      <description>

&lt;p&gt;#[名言] 不断的重构，模块会越来越壮大，功能会越来越多，代码会复杂，这时候开始重构。&lt;/p&gt;

&lt;h3 id=&#34;为啥鞋日志包:7fd877a2562cbb7976f27484b36083fa&#34;&gt;为啥鞋日志包&lt;/h3&gt;

&lt;p&gt;日志是debug不可或缺的模块，当出现问题时可以追踪问题、查看异常原因。作为后端服务，需要能够回溯问题并告知使用服务的同学问题出在哪里。
目前还未发现比较健壮、并且适用本地服务的开源日志包，所以只能自己动手。&lt;/p&gt;

&lt;h3 id=&#34;日志包的使用臆测:7fd877a2562cbb7976f27484b36083fa&#34;&gt;日志包的使用臆测&lt;/h3&gt;

&lt;p&gt;可以不初始化 - 单元测试、无需日志的时候，可以直接使用。
可以支持并发日志。－日志按块写入，根据pkid查看整个生命周期
可以不同端输出。－ 日志可以同时写入文件、控制台
可以多文件存储。－ 日志根据业务[组]写入不同的文件中&lt;/p&gt;

&lt;p&gt;我们会收到使用服务的同学的各种问题&lt;/p&gt;

&lt;h3 id=&#34;v3版本日志功能:7fd877a2562cbb7976f27484b36083fa&#34;&gt;v3版本日志功能：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;支持并发写入

&lt;ul&gt;
&lt;li&gt;块级写入&lt;/li&gt;
&lt;li&gt;原子操作ID&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多分组输出

&lt;ul&gt;
&lt;li&gt;按名字分别写入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多种输出方式

&lt;ul&gt;
&lt;li&gt;console - stdout&lt;/li&gt;
&lt;li&gt;file&lt;/li&gt;
&lt;li&gt;queue 队列输出&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;打印文件名，行号&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;日志与内置log-beego-log的区别:7fd877a2562cbb7976f27484b36083fa&#34;&gt;日志与内置log、BeeGo log的区别&lt;/h3&gt;

&lt;p&gt;使用为了简单，快速开发，以及更好的兼容本地服务。
log可以多文件存储，但是多种输出方式得封装
BeeGo可以多种输出方式，但是文件只能一个&lt;/p&gt;

&lt;p&gt;使用方式[简单版]:&lt;br /&gt;
var log *logv3.Logger = logv3.NewLog(nil)
log.Debug(&amp;ldquo;log debug&amp;rdquo;,1,2,&amp;ldquo;content&amp;rdquo;)
log.Error(&amp;ldquo;faild&amp;rdquo;)
输出到console：
[2015-10-22 11:33:22,debug] log debug 1 2 content
[2015-10-22 11:33:22,info] faild
[2015-10-22 11:33:22,debug] faild
[2015-10-22 11:33:22,error] faild&lt;/p&gt;

&lt;p&gt;使用方式:&lt;br /&gt;
//创建日志配置
var log_struct *logv3.LogStruct = &amp;amp;logv3.LogStruct{
    OpenFileLine : false,
    FileStruct:&amp;amp;logv3.FileStruct{
        LogPath:&amp;ldquo;/tmp/testlog/&amp;rdquo;,
        LogName:&amp;ldquo;log&amp;rdquo;,
    },
    ConsoleStruct:&amp;amp;logv3.ConsoleStruct{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
//创建一个logger
var log *logv3.Logger = logv3.NewLog(log_struct)
//创建一个分组
var group1 *logv3.Group  = log.NewGroup(&amp;ldquo;group_name1&amp;rdquo;)
group1.Debug(&amp;ldquo;log_debug1&amp;rdquo;)
//创建一个分组
var group2 *logv3.Group  = log.NewGroup(&amp;ldquo;group_name2&amp;rdquo;)
group2.Debug(&amp;ldquo;log_debug2&amp;rdquo;)
//原log可以继续使用
log.Debug(&amp;ldquo;log_debug0&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;会输出到console，并且写入文件
[2015-10-22 11:33:22,0,debug] log_debug1
[2015-10-22 11:33:22,0,debug] log_debug2
[2015-10-22 11:33:22,0,debug] log_debug0&lt;/p&gt;

&lt;p&gt;文件：/tmp/testlog/log-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,0,debug] log_debug0&lt;/p&gt;

&lt;p&gt;文件：/tmp/testlog/group_name1-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,1,debug] log_debug1&lt;/p&gt;

&lt;p&gt;文件：/tmp/testlog/group_name2-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,2,debug] log_debug2&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>