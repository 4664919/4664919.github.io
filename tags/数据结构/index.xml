<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on simons blog</title>
    <link>http://blog.simonsun.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on simons blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.simonsun.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>算法 － 二分查找(Binary Search)</title>
      <link>http://blog.simonsun.net/arithmetic-binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.simonsun.net/arithmetic-binary-search/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言：&lt;/h2&gt;

&lt;p&gt;算法时间复杂度按优劣排差不多集中在：&lt;/p&gt;

&lt;p&gt;O(1), O(log n), O(n), O(n log n), O(n2), O(nk), O(2n)&lt;/p&gt;

&lt;p&gt;到目前位置，似乎我学到的算法中，时间复杂度是O(log n),好像就数二分查找法，其他的诸如排序算法都是 O(n log n)或者O(n2)。但是也正是因为有二分的 O(log n), 才让很多 O(n2)缩减到只要O(n log n)。&lt;/p&gt;

&lt;p&gt;作用：&lt;/p&gt;

&lt;p&gt;二分查找法主要是解决在“一堆数中找出指定的数”这类问题。&lt;/p&gt;

&lt;p&gt;条件：&lt;/p&gt;

&lt;p&gt;想要应用二分查找法，这“一堆数”必须有一下特征：&lt;/p&gt;

&lt;p&gt;存储在数组中&lt;/p&gt;

&lt;p&gt;有序排列&lt;/p&gt;

&lt;p&gt;搜索值必须在数组中&lt;/p&gt;

&lt;p&gt;原理：&lt;/p&gt;

&lt;p&gt;二分查找算法就是不断将数组进行对半分割，每次拿中间元素和goal进行比较。&lt;/p&gt;

&lt;p&gt;代码示例：&lt;/p&gt;

&lt;p&gt;php:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;php&#34;&gt;
&amp;lt;?php
$array = array(1,3,4,6,6,6,7,8,9,10);

$search = 9;

$res = binarySearch($array,$search);

var_dump($res);

/**

* 二分查找(binary search)

* 返回搜索值在数组中的位置，如搜索不到返回false

*/

function binarySearch($array ,$search) {

$high = count($array) - 1;

$low = 0 ;

//搜索值不存在于数组中则搜索不到

if($search &amp;lt; $array[$low] || $search &amp;gt; $array[$high]){

return false ;

}

while ($low &amp;lt;= $high){

//取中间位置

$mid = floor($low + ($high - $low)/2) ;

if($array[$mid]&amp;gt;$search){//如果搜索值小于当前中间位置，则设置最大边界为当前中间位置－1

$high = $mid - 1 ;

}else if($array[$mid]&amp;lt;$search){//如果搜索值大于当前中间位置，则设置最小边界为当前边界＋1

$low  = $mid + 1 ;

}else{

//不大于也不小于就是等于了

return $mid ;

}

}

return false ;

}
?&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;golang:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
package main

import (

&#34;errors&#34;

&#34;fmt&#34;

)

func main() {

var array []int = []int{1, 3, 4, 6, 6, 6, 7, 8, 9, 10}

var search int = 9

var pos int

var err error

pos, err = binarySearch(array, search)

fmt.Println(pos)

fmt.Println(err)

}

func binarySearch(array []int, search int) (pos int, err error) {

var low int = 0

var high int = len(array) - 1

var middle int

for low &amp;lt;= high {

//取中间位置

middle = low + (high-low)/2

//如果搜索值小于当前中间位置，则设置最大边界为当前中间位置－1

if array[middle] &amp;gt; search {

high = middle - 1

continue

}

//如果搜索值大于当前中间位置，则设置最小边界为当前边界＋1

if array[middle] &amp;lt; search {

high = middle - 1

continue

}

//如果搜索值大于当前中间位置，则设置最小边界为当前边界＋1

if array[middle] &amp;lt; search {

low = middle + 1

continue

}

//不大于也不小于就是等于了

if array[middle] == search {

return middle, nil

}

}

return -1, errors.New(&#34;not find&#34;)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;缺陷&#34;&gt;缺陷：&lt;/h2&gt;

&lt;p&gt;二分查找法的O(log n)让它成为十分高效的算法。不过它的缺陷却也是那么明显的。就在它的限定之上：&lt;/p&gt;

&lt;p&gt;必须有序，我们很难保证我们的数组都是有序的。当然可以在构建数组的时候进行排序，可是又落到了第二个瓶颈上：它必须是数组。&lt;/p&gt;

&lt;p&gt;数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)。因而导致构建有序数组变成低效的事情。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>