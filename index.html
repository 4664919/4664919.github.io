<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.16-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> simons blog &middot; simons blog </title>

  
  <link rel="stylesheet" href="http://blog.simonsun.net/css/poole.css">
  <link rel="stylesheet" href="http://blog.simonsun.net/css/syntax.css">
  <link rel="stylesheet" href="http://blog.simonsun.net/css/hyde.css">
  <link rel="stylesheet" href="http://blog.simonsun.net/css/fonts.googleapis.com.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="http://blog.simonsun.net/index.xml" rel="alternate" type="application/rss+xml" title="simons blog" />
  
  <script src="http://blog.simonsun.net/js/jquery.min.js"></script>
  <script src="http://blog.simonsun.net/js/highlight.min.js"></script>
  <link rel="stylesheet" href="http://blog.simonsun.net/js/highlight-github.min.css">
  
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/javascript">
  $(document).ready(function() {
       
       
       
          });
</script>
</head>

<body class="theme-base-08">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.simonsun.net/"><h1>simons blog</h1></a>
      <p class="lead">
       这里是Simon Sun的个人博客 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/golang-beego-use/"> BeeGo初探 </a></li>
      
        <li><a href="/golang-code-source/"> Golang 源码初探 </a></li>
      
        <li><a href="/logv3/"> golang日志系统架构设计 </a></li>
      
        <li><a href="/welcome/"> 你好，Hugo </a></li>
      
        <li><a href="/s/"> 你好，Hugo2 </a></li>
      
        <li><a href="/golang-testing/"> 测试相关－golang </a></li>
      
        <li><a href="/arithmetic-binary-search/"> 算法 － 二分查找(Binary Search) </a></li>
      
        <li><a href="/golang-testing-code-coverage/"> 覆盖率测试－测试相关－golang </a></li>
      
    </ul>

    <p>&copy; 2016. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-testing/">
        测试相关－golang
      </a>
    </h1>

    <span class="post-date">2016-01-25</span>



    

<h2 id="测试的重要性:8e22fa101fec99f1e092801dd3c0bfd1">测试的重要性</h2>

<p>体现一个技术人员的牛逼之处离不开bug率。而bug率的多寡也离不开测试。除了bug率,时间成本(可重复性)。也是重点之之一。码农陷入在改bug-&gt;产生bug的怪圈中。而卓越的程序员一直在从卓越到更卓越的循环中。一个悲伤的故事：差距就这样拉开了。<br />
本文所说测试不是手工测试，手工测试的成本高的可怕。手工测试不是测试,那是在做实验。只要有人的因素牵涉其中，那结果就必然可疑。测试并不能杜绝bug。但测试能保证程序的行为是符合预期的.</p>

<p><em>测试可以分为很多种、叫法名字也不同。测试本身也是一个很宽泛的词。</em></p>

<h2 id="测试类别:8e22fa101fec99f1e092801dd3c0bfd1">测试类别：</h2>

<ol>
<li><p>功能测试、单元测试</p>

<ul>
<li>&lt;覆盖率测试 code coverage&gt;</li>
<li>随机测试</li>
<li>样本测试</li>
</ul></li>

<li><p>基准/基线测试 base line testing / benchmark testing</p>

<ul>
<li>性能测试  performance test</li>
</ul></li>

<li><p>负载测试 load testing</p></li>

<li><p>压力测试 stress testing</p></li>

<li><p>稳定性测试[可靠性] scalability testing</p></li>

<li><p>疲劳测试 endurance testing</p></li>

<li><p>组合测试 combination testing</p></li>

<li><p>远程/机房测试 remote/local testing</p></li>
</ol>

<h2 id="测试指标有哪些要关注的:8e22fa101fec99f1e092801dd3c0bfd1">测试指标有哪些要关注的：</h2>

<ol>
<li>每秒查询率[QPS Queries Per Second ]</li>
<li>响应时间[Response Time]：</li>
<li>服务器资源[]：</li>
<li>吞吐量[TPS Transactions Per Second]：</li>
<li>并发用户数<br /></li>
</ol>

<hr />

<ol>
<li>性能测试（可用性测试）    
主要是测试正常业务量下，成功率、每秒检索量、平均处理时间、服务器资源利用率。主要考察，该系统是否符合业务需求，能否达到上线要求。   </li>
<li>压力测试    
测试峰值情况下，长时间连续运行系统给系统性能造成的影响。</li>
<li>负载测试
测试不同并发数下，单机/单套系统的极限并发。</li>
<li>容量测试    
主要是测试数据量非常大的情况下，内存、磁盘、访问性能。一般系统刚上线，数据量较小，性能一般没有什么问题，把数据放大到百万、千万量级，再测测系统，可能之前未能暴露的问题就出来了。   </li>
<li>疲劳测试    
连续24小时以上测试，看有没有内存碎片和内存泄露等问题.</li>
<li>配置测试    
不同参数下的性能，后台程序会有很多开关，需要测试主要的开关情况下对性能的影响，或者不同的参数数量对于性能的影响。比较简单的例子就是，索引长度设置为128和1024对于系统的性能究竟有多大的影响。</li>
</ol>

<p>并发用户数和QPS两个概念没有直接关系，但是如果要说QPS时，一定需要指明是多少并发用户数下的QPS，</p>

<h3 id="实际上性能是一个很很宽泛的词-系统出了问题大多归结为性能有问题-比如访问速度慢-占用资源过多-时不时宕机等等-但是这属于不同性能问题的范畴-而且测试方法也不尽相同-性能测试监控指标主要分为-资源指标和系统指标-资源指标与硬件资源消耗直接相关-而系统指标则与用户场景及需求直接相关:8e22fa101fec99f1e092801dd3c0bfd1">实际上性能是一个很很宽泛的词，系统出了问题大多归结为性能有问题，比如访问速度慢，占用资源过多，时不时宕机等等，但是这属于不同性能问题的范畴，而且测试方法也不尽相同。<em>性能测试监控指标主要分为：资源指标和系统指标，资源指标与硬件资源消耗直接相关，而系统指标则与用户场景及需求直接相关</em></h3>

<p><img src="/upload/web-test.jpg" alt="" /></p>

<p>术语说明：
QPS = req/sec = 请求数/秒
【QPS计算PV和机器的方式】
QPS统计方式 [一般使用 http_load 进行统计]
QPS = 总请求数 / ( 进程总数 *   请求时间 )
QPS: 单个进程每秒请求服务器的成功次数</p>

<p>单台服务器每天PV计算
公式1：每天总PV = QPS * 3600 * 6
公式2：每天总PV = QPS * 3600 * 8</p>

<p>服务器计算
服务器数量 =   ceil( 每天总PV / 单台服务器每天总PV )</p>

<p>【峰值QPS和机器计算公式】</p>

<p>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间
公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)
机器：峰值时间每秒QPS / 单台机器的QPS   = 需要的机器</p>

<p>问：每天300w PV 的在单台机器上，这台机器需要多少QPS？
答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</p>

<p>问：如果一台机器的QPS是58，需要几台机器来支持？
答：139 / 58 = 3</p>

<p>QPS提升带来什么？QPS提升说明单台服务器处理能力提升，如果QPS提升1倍，服务器资源减少1半，或者说服务器不变可以支撑2倍的请求量。
如何提升QPS？
1）减少CPU的使用时间（哪些代码会消耗CPU：循环、字符串拼接\查找\替换、编码\解码、序列化\反序列化、压缩）
2）增加CPU的数量
3）减少同步锁
（如果CPU不能被压到85%以上，并且此时的QPS已经达到了峰值，则说明另有瓶颈，接下去关注内存）
RT提升带来什么？
响应速度提升说明单词请求的处理速度提升，用户感觉任务处理速度更快，系统反应速度更快。当然在处理能力不变的情况下，RT的提升必然会提升QPS。
如何提升RT？
1）减少I/O的响应时间
2）减少I/O的调用次数
3）减少CPU使用时间（当然在I/O占大头的应用里，这方面优化效果肯定不明显）</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-testing-code-coverage/">
        覆盖率测试－测试相关－golang
      </a>
    </h1>

    <span class="post-date">2016-01-25</span>



    

<h3 id="相关参数:4df3722ce16d4ff7fa64d0a0ba971114">相关参数</h3>

<table>
<thead>
<tr>
<th>名称</th>
<th>示例</th>
<th>注释</th>
</tr>
</thead>

<tbody>
<tr>
<td>-cover</td>
<td>-cover</td>
<td>表示开启覆盖率</td>
</tr>

<tr>
<td>-covermode</td>
<td>-covermode=set</td>
<td>覆盖率统计模式：   <br>set只记录是否执行过.  <br> count统计执行次数. <br>原子方式atomic统计执行次数.</td>
</tr>

<tr>
<td>-coverpkg</td>
<td>-coverpkg pkg1,pkg2,pkg3</td>
<td>统计覆盖测试其他包，多个以，号分隔</td>
</tr>

<tr>
<td>-coverprofile</td>
<td>-coverprofile cover.out</td>
<td>数据写入到指定文件</td>
</tr>
</tbody>
</table>

<hr>

<h3 id="demo:4df3722ce16d4ff7fa64d0a0ba971114">DEMO</h3>

<pre><code class="shell">
go test -cover -coverprofile cover.out ./logv3/
ok      xidibuy/logv3   0.010s  coverage: 65.1% of statements
</code></pre>
cover.out 内容：
<pre><code class="shell">
mode: set                                                                                                                                      
xidibuy/logv3/console.go:21.68,24.2 2 1
xidibuy/logv3/console.go:26.51,30.26 2 1
xidibuy/logv3/console.go:33.2,34.12 2 1
xidibuy/logv3/console.go:30.26,32.3 1 1
xidibuy/logv3/console.go:36.30,38.2 0 0
xidibuy/logv3/console.go:39.28,41.2 0 0
xidibuy/logv3/file.go:20.59,24.2 2 1
xidibuy/logv3/file.go:26.48,30.26 2 1
xidibuy/logv3/file.go:33.2,34.12 2 1
xidibuy/logv3/file.go:30.26,32.3 1 0
xidibuy/logv3/file.go:36.27,38.2 0 0
...
</code></pre>

<p>以上输出详情并不利于人来观看，可使用go tool 查看html格式的内容
<pre><code class="shell">
go tool cover -html=cover.out
</code></pre>
<img src="/upload/golang-testing-code-coverage.png" alt="" /></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/welcome/">
        你好，Hugo
      </a>
    </h1>

    <span class="post-date">2015-09-23</span>



    <p>这是使用Hugo创建的站点中的第一篇文章。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/s/">
        你好，Hugo2
      </a>
    </h1>

    <span class="post-date">2015-09-23</span>



    <p>这是使用Hugo创建的站点中的第一篇文章。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/architecture%E6%9E%B6%E6%9E%84/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>校长:技术成长四个阶段需要的架构知识
<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=406063297&amp;idx=1&amp;sn=0cd1fc5495e1e26471d7a4ffcd96cd0f&amp;scene=0&amp;key=b28b03434249256b87a3205a0ce9eb3072cff80abad4d034f85998222c6634f5b8dc902bf152b2fcf7350e2e1f325be3&amp;ascene=0&amp;uin=MTc0NTg4Nzc0MQ%3D%3D&amp;devicetype=iMac+MacBookAir6%2C2+OSX+OSX+10.11.3+build(15D21)&amp;version=11020201&amp;pass_ticket=raryIxNpwn282neBUxUUUienKC3%2FoHLL5k5MXpgtOZa0lAa2nn5uzc0RHHd5peGF">https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=406063297&amp;idx=1&amp;sn=0cd1fc5495e1e26471d7a4ffcd96cd0f&amp;scene=0&amp;key=b28b03434249256b87a3205a0ce9eb3072cff80abad4d034f85998222c6634f5b8dc902bf152b2fcf7350e2e1f325be3&amp;ascene=0&amp;uin=MTc0NTg4Nzc0MQ%3D%3D&amp;devicetype=iMac+MacBookAir6%2C2+OSX+OSX+10.11.3+build(15D21)&amp;version=11020201&amp;pass_ticket=raryIxNpwn282neBUxUUUienKC3%2FoHLL5k5MXpgtOZa0lAa2nn5uzc0RHHd5peGF</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/arithmetic-%E7%AE%97%E6%B3%95/base/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>va 编程模型、
数据抽象、基本数据结构、集合类的抽象数据类型、算法性能分析的方法和一个案例分析。
第 2 章 排序
有序地重新排列数组中的元素是非常重要的基础算法。我们会深入研究各种排序算法,包括插
入排序、选择排序、希尔排序、快速排序、归并排序和堆排序。同时我们还会讨论另外一些算法, 它们用于解决几个与排序相关的问题,例如优先队列、选举以及归并。其中许多算法会成为后续章 节中其他算法的基础。
第 3 章 查找
从庞大的数据集中找到指定的条目也是非常重要的。我们将会讨论基本的和高级的查找算法, 包括二叉查找树、平衡查找树和散列表。我们会梳理这些方法之间的关系并比较它们的性能。
第 4 章 图
图的主要内容是对象和它们的连接,连接可能有权重和方向。利用图可以为大量重要而困难的 问题建模,因此图算法的设计也是本书的一个主要研究领域。我们会研究深度优先搜索、广度优先 搜索、连通性问题以及若干其他算法和应用,包括 Kruskal 和 Prim 的最小生成树算法、Dijkstra 和 Bellman-Ford 的最短路径算法。
第 5 章 字符串
字符串是现代应用程序中的重要数据类型。我们将会研究一系列处理字符串的算法,首先是对
字符串键的排序和查找的快速算法,然后是子字符串查找、正则表达式模式匹配和数据压缩算法。 此外,在分析一些本身就十分重要的基础问题之后,这一章对相关领域的前沿话题也作了介绍。
第 6 章 背景
这一章将讨论与本书内容有关的若干其他前沿研究领域,包括科学计算、运筹学和计算理论。 我们会介绍性地讲一下基于事件的模拟、B 树、后缀数组、最大流量问题以及其他高级主题,以帮 助读者理解算法在许多有趣的前沿研究领域中所起到的巨大作用。最后,我们会讲一讲搜索问题、 问题转化和 NP 完全性等算法研究的支柱理论,以及它们和本书内容的联系。</p>

<p>目前(略读)读到：</p>

<p>算法完全版－257
aha算法 读完</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/bug%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>bug从哪来</p>

<p>造成bug的原因</p>

<ol>
<li>程序员本身.不负责bug光环</li>
<li>产品bug</li>
<li>需求变更</li>
<li>技术bug</li>
</ol>

<p>如何避免bug</p>

<p>自动化测试[
    随机测试
    &hellip;
]
没有银弹</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/eight-queens-puzzle-testing-with-language/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: 八皇后问题在各语言下执行时间测试
tags:
  - 数据结构
  - 性能
  - 测试
  - 算法</p>

<h2 id="date-2015-05-07-17-52-10:0fc52dc52cd09d55edbc1c2b05363e2a">date: 2015-05-07 17:52:10</h2>

<h3 id="新增-2015-09-06-17-32-28:0fc52dc52cd09d55edbc1c2b05363e2a">新增 - 2015-09-06 17:32:28</h3>

<p><em>由于测试代码未保留（测试的时候直接存/tmp了）导致没有源代码，故也就没有后续了。。。</em></p>

<hr />

<p>前几天公司内部同事想测试下语言的效率，当时使用八皇后问题进行测试（实际应用中代码都为九皇后），</p>

<p>目前测试覆盖的代码有 C,GO,JAVA,PHP</p>

<p>待写测试代码的有：PYTHON,RUBY,NODEJS,JS</p>

<p>目前效率最高的是C语言，其次是GO，然后是JAVA，最慢的是PHP</p>

<p>其中C语言在优化后可达到1毫秒，未优化2毫秒</p>

<p>GO运行在2-3毫秒之间</p>

<p>JAVA为4毫秒</p>

<p>PHP达到80毫秒左右，开APC达到56毫秒，通过查看OPCODE各种优化达到40毫秒（这时候已经影响到可读性了）</p>

<p>附效率截图：</p>

<p>优化后的C</p>

<p><img src="/upload/eight-queens-puzzle-testing-with-language-optimize-c.jpeg" alt="" /></p>

<p>未优化的C</p>

<p><img src="/upload/eight-queens-puzzle-testing-with-language-c.jpeg" alt="" /></p>

<p>JAVA</p>

<p><img src="/upload/eight-queens-puzzle-testing-with-language-java.jpeg" alt="" /></p>

<p>开启APC后的PHP</p>

<p><img src="/upload/eight-queens-puzzle-testing-with-language-apc-php.jpeg" alt="" /></p>

<p>未开启APC的PHP</p>

<p><img src="/upload/eight-queens-puzzle-testing-with-language-php.jpeg" alt="" /></p>

<p>&nbsp;</p>

<p>golang:</p>

<p>total results: 352
total time: 2</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/english-%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%E7%9A%84%E5%A5%A5%E7%A7%98/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>第一部分124个词
第二部分125-252 个词
第三部分:page 308－347
第四部分:page 347-423</p>

<h1 id="词根:4a79cc836e36abf0d14b07014fbd72c3">词根</h1>

<h2 id="掌握词根-分析单词:4a79cc836e36abf0d14b07014fbd72c3">掌握词根，分析单词</h2>

<ol>
<li>ag
ag = do ,act 做，动</li>
</ol>

<p>agent
agency
cogent</p>

<ol>
<li>agri
agri = field 田地，农田
agri 也作 agro,agr</li>
</ol>

<p>agrestic
agriculture
agronomy</p>

<p>3.ann
ann = year年
ann 也作 enn</p>

<p>annals
perennial</p>

<ol>
<li>audi
audi = hear 听
audi 也作 audit</li>
</ol>

<p>audit
auditor
audio</p>

<ol>
<li>bell
bell = war 战争</li>
</ol>

<p>rebel
bellicose
bellicism</p>

<p>6.brev
bred = short 短</p>

<p>brevity
brief
breviary</p>

<ol>
<li>ced
red = go 行走
ced也作ceed cess</li>
</ol>

<p>exceed
proceed
process
success</p>

<ol>
<li>cept
cept = take 拿，取</li>
</ol>

<p>except
accept
incept</p>

<ol>
<li>cid,cis
cid,cis = cut,kill 切，杀</li>
</ol>

<p>decide
decidable
incise</p>

<ol>
<li>circ
circa = ring 环，圆</li>
</ol>

<p>circular
circus
encircle</p>

<ol>
<li>claim,clam
claim,clam = cry,shout 喊叫</li>
</ol>

<p>exclaim
acclaim
declaim</p>

<ol>
<li>clar
clar = clear 清楚明白</li>
</ol>

<p>declare
declarer
clarity</p>

<ol>
<li>clud
clud = close,shut 关闭
clud也作clus</li>
</ol>

<p>exclude
include
seclude</p>

<ol>
<li>cogn
cogn = know 知道</li>
</ol>

<p>cognition
cognize
cognizant</p>

<ol>
<li>cord
cord = heart 心</li>
</ol>

<p>record
recorder
discord
accord</p>

<ol>
<li>corpor
corpor = body 体
corpor 也作 corp</li>
</ol>

<p>corporate
corporal
incorporation</p>

<p>17.cred
cred = believe,trust 相信，信任</p>

<p>credible
incredible
credit
creed</p>

<ol>
<li>cruc
cruc = cross 十字</li>
</ol>

<p>crucial
crucise
excruciate</p>

<ol>
<li>cur
cur = care 关心，挂念，注意</li>
</ol>

<p>secure
curious
curable</p>

<ol>
<li><p>cur,curs,cour,cours
cur,curs,cour,cours = run 跑
courser
occurrent
excure</p></li>

<li><p>dent
dent = tooth 牙齿</p></li>
</ol>

<p>dentist
dental
bident</p>

<ol>
<li>di
di = day 日</li>
</ol>

<p>diary
dial
meridian
antemeridian</p>

<ol>
<li>dict
dict = say 言，说
dict 也作 dic</li>
</ol>

<p>dictation
dictate
contradiction</p>

<ol>
<li>dit
dit = give 给</li>
</ol>

<p>edit
editor
editorship</p>

<p>25.don
don = give 给
don 也作 do</p>

<p>pardon
pardoner
donee</p>

<ol>
<li>du
du = two 二</li>
</ol>

<p>dual
dualize
duet</p>

<p>27.duc
duc , duct = lead 引导</p>

<p>educate
conduct
produce</p>

<ol>
<li>ed
ed = eat 吃</li>
</ol>

<p>edible
inedible
edacity</p>

<ol>
<li>equ
equ = equal 等，均，平</li>
</ol>

<p>equal
equality
adequate</p>

<ol>
<li>ev
ev = age 年龄</li>
</ol>

<p>longevity
coeval
primeval</p>

<ol>
<li>fact
fact = do,make 做
fact 也作 fac</li>
</ol>

<p>factory
benefactor
facile</p>

<ol>
<li>fer
fer = bring,carry 带，拿</li>
</ol>

<p>confer
differ
prefer</p>

<ol>
<li>flor
flor = flower 花
flor 也作 flour</li>
</ol>

<p>florid
floral
defloration</p>

<ol>
<li>flu
flu = flow 流</li>
</ol>

<p>fluent
fluency
influenza</p>

<ol>
<li>fus
fus = pour 灌，流，倾泻</li>
</ol>

<p>refuse
refusal
diffusion</p>

<ol>
<li>grad
grad = step,go,grade 步，走，级</li>
</ol>

<p>gradual
retorgrade
degrade</p>

<ol>
<li>gram
gram = write,something,written or drawn 写，画，文字，图形</li>
</ol>

<p>grammar
grammarian
kilogram</p>

<ol>
<li>graph
graph = write,writing,an instrument for making records 写，画，图形，记录器</li>
</ol>

<p>photograph
geography
biography</p>

<ol>
<li>gress
gress = go,walk 行走</li>
</ol>

<p>progress
retrogress
congressional</p>

<ol>
<li>habit
habit = dwell 居住</li>
</ol>

<p>habitable
inhabit
cohabit</p>

<ol>
<li>hibit
hibit = hold 拿，持</li>
</ol>

<p>exhibit
inhibit
prohibit</p>

<ol>
<li>hospit
hospit = guset</li>
</ol>

<p>hospital
hospitable
inhospitable</p>

<ol>
<li>idio
idio = peculiar,own,private,proper 特殊的，个人的，专有的</li>
</ol>

<p>idiom
idiot
idiocy</p>

<ol>
<li>insul
insul = island 岛</li>
</ol>

<p>peninsula
peninsular
insulate</p>

<ol>
<li>it
it = go 行走</li>
</ol>

<p>exit
initial
transit</p>

<ol>
<li>ject
ject = throw 投掷</li>
</ol>

<p>project
inject
subject</p>

<ol>
<li>juven
juven = young 年轻，年少</li>
</ol>

<p>juvenile
juvenility
rejuvenator</p>

<ol>
<li>lect
lect = choose,gather 选，收
lect 也作 leg,lig</li>
</ol>

<p>select
selection
intellect</p>

<ol>
<li>lev
lev = raise 举，升</li>
</ol>

<p>elevate
elevation
relieve</p>

<ol>
<li>liber
liber = free 自由</li>
</ol>

<p>liberate
liberty
liberal</p>

<ol>
<li>lingu
lingu = language 语言</li>
</ol>

<p>collingual
linguist
linguist</p>

<ol>
<li>liter
liter = letter 文字，字母</li>
</ol>

<p>literate
literacy
bilateral</p>

<ol>
<li>loc
loc = place 地方</li>
</ol>

<p>local
localism
dislocate</p>

<ol>
<li>log
log = speak 言，说</li>
</ol>

<p>dialogue
eulogy
monologue</p>

<ol>
<li>loqu
loqu =speak 言，说</li>
</ol>

<p>eloquent
soliloquy
obloquy</p>

<ol>
<li>lun
fun = moon 月亮</li>
</ol>

<p>lunar
semilunar
lunet</p>

<ol>
<li>man
man = dwell , stay 居住停留</li>
</ol>

<p>manor
manorial
remain</p>

<ol>
<li>manu
manu = hand 手</li>
</ol>

<p>mannscript
manufacturer
manual</p>

<ol>
<li>mar
mar = sea 海</li>
</ol>

<p>marine
mariner
marigraph</p>

<ol>
<li>medi
media = middle 中间</li>
</ol>

<p>immediate
medium
medial</p>

<ol>
<li>memor
memor = memory</li>
</ol>

<p>memory
memorial
immemorial</p>

<ol>
<li>merg
merg = dip,sink 沉，没
merg 也作 mers</li>
</ol>

<p>emerge
emergence
emergent</p>

<ol>
<li>migr
migr = remove,move 迁移</li>
</ol>

<p>emigrate
migrant
immigrate</p>

<ol>
<li>milit
milit = soldier 兵</li>
</ol>

<p>militia
military
hypermilitant</p>

<ol>
<li>mini
mini = small,little 小
mini 也作 min</li>
</ol>

<p>minister
ministry
minim</p>

<ol>
<li>mir
mir = wonder 惊奇，惊异</li>
</ol>

<p>mirror
admire
miracle</p>

<ol>
<li>miss
miss = send 投，送，发
miss 也作 mit</li>
</ol>

<p>missile
dismiss
manumit</p>

<ol>
<li>mob
mob = move 动</li>
</ol>

<p>mobile
demobilize
mob</p>

<ol>
<li>mort
mort = death 死</li>
</ol>

<p>mortal
immortal
postmortem</p>

<ol>
<li>mot</li>
</ol>

<p>mot = move 移动，动</p>

<p>motion
motive
promote</p>

<ol>
<li>nomin
nomin = name 名</li>
</ol>

<p>nominal
nominate
ignominy</p>

<ol>
<li>nov
nov = new 新</li>
</ol>

<p>novel
innovate
renovate</p>

<ol>
<li>numer
number = number 数</li>
</ol>

<p>numeral
numerator
enumerate</p>

<ol>
<li>onym
onym = name 名</li>
</ol>

<p>anonym
anonymity
synonym</p>

<ol>
<li>oper
oper = work 工作</li>
</ol>

<p>operate
operator
cooperative</p>

<ol>
<li>ori
ori = rise 升起</li>
</ol>

<p>orient
oriental
origin</p>

<ol>
<li>paci
paci = peace 和平，平静</li>
</ol>

<p>pacific
pacify
pacifier</p>

<ol>
<li>pel
pel = push,drive 推，逐，驱</li>
</ol>

<p>propel
propeller
expel</p>

<ol>
<li>pend
pend,pens = hang 悬挂</li>
</ol>

<p>depend
dependent
suspend</p>

<p>pend,pens = weigh 称量</p>

<p>dispense
ponder
ponderable</p>

<p>pend,pens =pay 付钱，支出，花费</p>

<p>expend
expenditure
pension</p>

<ol>
<li>pet
pet = seek 追求</li>
</ol>

<p>compete
competition
competitive</p>

<ol>
<li>phon
phon = sound 声音</li>
</ol>

<p>telephone
microphone
phonic</p>

<ol>
<li>pict
pict = paint 画，描绘</li>
</ol>

<p>picture
picturize
depict</p>

<ol>
<li>plen
plen = full 满，全</li>
</ol>

<p>plenty
plentiful
plenitude</p>

<ol>
<li>plic
plic = fold 折，重叠</li>
</ol>

<p>complicate
explicable
duplicity</p>

<ol>
<li>pon
pon = put 放置</li>
</ol>

<p>postpone
antepone
component</p>

<p>popul
popul = people 人民</p>

<p>population
populous
populate</p>

<ol>
<li>port
port = carry 拿，带，运</li>
</ol>

<p>portable
import
export</p>

<ol>
<li>pos</li>
</ol>

<p>pos = put 放置</p>

<p>expose
compose
oppose</p>

<ol>
<li>preci
preci = price 价值</li>
</ol>

<p>precious
appreciate
appreciative</p>

<ol>
<li>punct
punct = point,prick 点，刺</li>
</ol>

<p>punctuate
punctate
punctual</p>

<ol>
<li>pur
pur = pure 清，纯，净</li>
</ol>

<p>purify
purification
purism</p>

<ol>
<li>rect
rect = right,straight 正，直</li>
</ol>

<p>correct
corrective
rectify</p>

<ol>
<li>rupt
rupt = break 破</li>
</ol>

<p>rupture
interrupt
corrupt</p>

<ol>
<li>sal
sal = salt 盐</li>
</ol>

<p>salary
salad
saline</p>

<ol>
<li>scend
scend,scens = climb 爬，攀</li>
</ol>

<p>ascend
ascent
descent</p>

<ol>
<li>sci
sci = know 知</li>
</ol>

<p>science
scientist
consciousness</p>

<ol>
<li>sec,sequ</li>
</ol>

<p>sec,sequ = follow 跟随</p>

<p>second
sequence
sequent</p>

<ol>
<li>sect
sect = cut 切割</li>
</ol>

<p>insect
sectile
bisect</p>

<ol>
<li>sent
sent,sens = feel 感觉</li>
</ol>

<p>consent
dissent
resent</p>

<ol>
<li>sid
sid = sit 坐</li>
</ol>

<p>preside
president
reside</p>

<ol>
<li>sist
sist = sand 站立</li>
</ol>

<p>consist
assist
exist</p>

<ol>
<li>son
son = sound 声音</li>
</ol>

<p>sonic
subsonic
resonator</p>

<ol>
<li>spect
spect = look 看</li>
</ol>

<p>spectacle
prospect
inspect</p>

<ol>
<li>spir
spir = breathe 呼吸</li>
</ol>

<p>conspire
expire
respire</p>

<ol>
<li>tail
tail = cut 切割</li>
</ol>

<p>tailor
detail
retail</p>

<ol>
<li>tain,tan,tin
tain,ten,tin = hold 握，持，守</li>
</ol>

<p>contain
obtain
tenant</p>

<ol>
<li>tect
tect = cover 掩盖</li>
</ol>

<p>detect
protector
unprotected</p>

<ol>
<li>tele
tele = far 远</li>
</ol>

<p>telecontrol
telescope
telephone</p>

<ol>
<li>tempor
tempor = time 时</li>
</ol>

<p>temporary
contemporary
extemporize</p>

<ol>
<li>tend
tend tens,tent = stretch 伸</li>
</ol>

<p>extend
extensive
attend</p>

<ol>
<li>terr
terr = earth,land 土地，陆地</li>
</ol>

<p>territory
territorial
inter</p>

<ol>
<li>text
text = weave 编织</li>
</ol>

<p>textile
texture
text
context</p>

<ol>
<li>tract
tract = draw 拉，抽，引</li>
</ol>

<p>tractor
attract
protract</p>

<p>un
un = one
un 也作 uni</p>

<p>unite
united
unitive</p>

<ol>
<li>urb
urb = city 城市</li>
</ol>

<p>suburb
suburban
suburbanize</p>

<ol>
<li>vac
vac = empty 空
vac 也作 vacu</li>
</ol>

<p>vacation
vacancy
vacate</p>

<ol>
<li>vad
vad vas = walk,go 行走</li>
</ol>

<p>invader
invade
invasive</p>

<ol>
<li>vari
vari = change 改变</li>
</ol>

<p>variable
invariable
various</p>

<ol>
<li>ven
ven = come 来</li>
</ol>

<p>intervene
intervention
convene</p>

<ol>
<li>vert
vert , vers = turn 转</li>
</ol>

<p>advertise
subvert
divert</p>

<ol>
<li>vi, via
vi,via = way</li>
</ol>

<p>obvious
trivial
deviate</p>

<ol>
<li>vis
vis,vid = see 看</li>
</ol>

<p>visible
invisible
visitor</p>

<ol>
<li>vit
vit = life 生命</li>
</ol>

<p>vital
devitalize
avitaminosis</p>

<ol>
<li>viv
viv = live 活</li>
</ol>

<p>survive
survival
vivisect</p>

<h2 id="多认词根-多识单词:4a79cc836e36abf0d14b07014fbd72c3">多认词根，多识单词</h2>

<ol>
<li>aer[0] 空气，空中，航空</li>
</ol>

<p>aerial
aerology
aerogram</p>

<ol>
<li><p>alt 高
alto
exalt
altar</p></li>

<li><p>am 爱
[am爱 ateur ＝ ator 表示人] 业余爱好者</p></li>
</ol>

<p>amatory
amateurish
amour</p>

<ol>
<li>ambul 行，走</li>
</ol>

<p>ambulannce</p>

<p>page=page - 21
page:120
page:138
page:172</p>

<h1 id="单词的附件-词缀:4a79cc836e36abf0d14b07014fbd72c3">单词的附件－词缀</h1>

<h2 id="前缀:4a79cc836e36abf0d14b07014fbd72c3">前缀</h2>

<h2 id="后缀:4a79cc836e36abf0d14b07014fbd72c3">后缀</h2>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/english/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<h1 id="字母发音的重要性:b6b595a68cd480ac7859f3dfec888e20">字母发音的重要性</h1>

<p>说到这，先简单介绍下【自然拼读法】吧。
具体的官方介绍可以自己搜百度。
摘自百度百科的：
英语自然拼读法通过直接学习26个字母及字母组合在单词中的发音规则，建立字母及字母组合与发音的感知，让学生在轻松愉快的氛围中，了解和学习英语字母组合的奥妙，掌握英语拼读规律，从而达到看到单词就会读，听到单词就会拼的学习目的。
对于大多数英语初学者，自然拼读法是一门实用的工具与方法，如能掌握，不需要借助音标，就都能够读出80%的英语单词，把枯燥无味的背单词变成一件简单的事，从而达到事半功倍的效果。</p>

<p>通俗点的解释就是：
26个字母的发音规律就跟我们的拼音是一个道理。
也就是说，每个字母在单词中都会有相应的发音规律，那么当几个字母组成一个单词时，我们就可以像拼拼音一样，通过字母的发音规律而把单词拼读出来。
就像，如果你懂了拼音，看到拼音组合在一起时，就会自然而然的拼读出来一样。</p>

<p>接下来举个例子。
例如a，在单词钟大部分发梅花音/æ/，apple，ant（蚂蚁），ax（斧头），这就是一个发音规律。那么如果掌握了这个发音规律，当你听到 /æ/ 的发音的时候，就会想到可能单词里面就有a这个字母。
如此下来，总共英语就26个字母，那么你把26个字母的发音规律都掌握了，
当听到一些比较简单的单词的时候，脑海里就会潜意识的把单词给拼写出来了。
单词也就自然而然的记住了。</p>

<p>比如讲个难点的单词 [ trəˈdɪʃən ] ，如果听到这个单词，该如何拼写。
首先把音节分开，/trə/，能发/tr/字母的组合里面，就只有tr，tr后面能发/ə/的音里面字母就大概只有a了。
那么前面三个字母就是tra， 接下来及时/di/，这个大部分一听都没问题，绝对是di两个字母。
最后/ʃən/ ，这是一个英文非常常见的字母组合，看到这个学过音标的人，想都不用想就知道一定是tion这个字母组合。
其实这些都是最基础的音标发音规则。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/github/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>搜索高级技巧：
搜索星级排行
stars:&gt;1000
例如：<a href="https://github.com/search?l=Go&amp;q=stars%3A%3E1000&amp;ref=searchresults&amp;type=Repositories&amp;utf8=%E2%9C%93">https://github.com/search?l=Go&amp;q=stars%3A%3E1000&amp;ref=searchresults&amp;type=Repositories&amp;utf8=%E2%9C%93</a></p>

<p>搜索中国用户
location:China
<a href="https://github.com/search?q=location%3AChina&amp;ref=searchresults&amp;type=Users&amp;utf8=%E2%9C%93">https://github.com/search?q=location%3AChina&amp;ref=searchresults&amp;type=Users&amp;utf8=%E2%9C%93</a></p>

<h1 id="使用技巧:93ed8abeb42c248f3c551d1cb44159d4">使用技巧</h1>

<p>#基础命令
git init 创建新的仓库
git clone 把仓库克隆到本地</p>

<p>git add 添加文件到本地仓库
git status 查看当前状态
git diff 对比
git commit 提交到本地仓库
git reset HEAD 猜测为 revert
git rm 删除
git mv 挪动
git log 查看提交历史</p>

<h1 id="分支:93ed8abeb42c248f3c551d1cb44159d4">分支</h1>

<p>git branch (branchname) 创建分支
git checkout (branchname) 切换分支
git merge  合并分支</p>

<p>git branch 列出分支
git branch -d (branchname)  删除分支</p>

<h1 id="tag:93ed8abeb42c248f3c551d1cb44159d4">tag</h1>

<p>git tag -a v1.0</p>

<p>#远程仓库
git remote 查看远程仓库
git fetch 从远程仓库下载新分支与数据：
git pull  从远端仓库提取数据并尝试合并到当前分支</p>

<p>#diff
    尚未缓存的改动：git diff
    查看已缓存的改动： git diff &ndash;cached
    查看已缓存的与未缓存的所有改动：git diff HEAD
    显示摘要而非整个 diff：git diff &ndash;stat
#log
    我们可以用 &ndash;oneline 选项来查看历史记录的简洁的版本。
    我们还可以用 &ndash;graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：
    你也可以用 &lsquo;&ndash;reverse&rsquo;参数来逆向显示所有日志。
    如果只想查找指定用户的提交日志可以使用命令：git log &ndash;author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：
    如果你要指定日期，可以执行几个选项：&ndash;since 和 &ndash;before，但是你也可以用 &ndash;until 和 &ndash;after。</p>

<h1 id="tab:93ed8abeb42c248f3c551d1cb44159d4">tab</h1>

<pre><code>  -a 选项意为&quot;创建一个带注解的标签&quot;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-daemon/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: golang 守护进程 daemon 实现方式
tags:
  - golang
  - daemon
  - 守护进程</p>

<h2 id="date-2015-05-07-17-51-12:0c0705ff9f709abf9a574c9ef808216c">date: 2015-05-07 17:51:12</h2>

<p>技术点：</p>

<ul>
<li>执行代码增加了一个开关，用来判断是否已经是daemon形式启动了</li>
<li>使用linux内置守护进程运行命令</li>
</ul>

<p>具体逻辑：</p>

<p>程序在刚启动的时候包中init函数优先执行，执行后验证是否存在守护进程开关，如果存在并且当前进程不是守护进程模式则使用守护进程方式启动应用并退出当前进程</p>

<p>需要注意的：golang的flag包的逻辑是所有参数必须都是flag方式，否则就不解析。我在做的时候是有非flag方式的，所以只能自己动手丰衣足食了</p>

<p>伪代码示例：</p>

<p>包：</p>

<p>func init(){</p>

<p>//验证是否存在守护进程开关</p>

<p>if daemon_args_exist(){</p>

<p>//当前进程不是守护进程模式</p>

<p>if ! is_daemon_progress() {</p>

<p>//守护进程方式启动应用</p>

<p>star_daemon()</p>

<p>//并退出当前进程</p>

<p>os.Exit(0)</p>

<p>}</p>

<p>}</p>

<p>&nbsp;</p>

<p>}</p>

<p>应用入口main：</p>

<p>import(</p>

<p>//只要引入包即可，无需其他操作</p>

<p>_ “xidibuy/daemon&#8221;</p>

<p>)</p>

<p>另外下面传送门的这个git是有bug的，当有参数不全部为flag的时候，就会失效。</p>

<p>思路参考了： <a href="http://github.com/icattlecoder/godaemon">github.com/icattlecoder/godaemon</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-flag/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: golang使用flag中遇到的问题
tags:
  - golang
  - flag</p>

<h2 id="date-2015-09-06-16-59-30:b466e8f2132e47affd6bf66f8fd23a0b">date: 2015-09-06 16:59:30</h2>

<h1 id="关于flag:b466e8f2132e47affd6bf66f8fd23a0b">关于flag</h1>

<p>在开发golang项目中，有用到flag。在使用中遇到一些问题：</p>

<ol>
<li>多次解析flag，会覆盖之前的：</li>
</ol>

<h2 id="出现的具体问题:b466e8f2132e47affd6bf66f8fd23a0b">出现的具体问题：</h2>

<blockquote>
<p>在开发项目包中<a href="/golang-daemon.html">守护进程 daemon 实现方式 </a>、<a href="/golang-pprof.html">关于golang性能调试</a> 两个包会有冲突：如果有多个flag的parse函数，只首次运行的parse管用.</p>
</blockquote>

<p>代码示例：
包a:
{% codeblock lang:golang %}
func init() {
    if daemon_args_exist() {
        flag.Parse()<br />
        &hellip;
    }<br />
}
{% endcodeblock %}</p>

<p>包b:
{% codeblock lang:golang %}
func parseProfFlags() {
    if !flag.Parsed() {<br />
        flag.Parse()
    }<br />
    &hellip;
}</p>

<p>{% endcodeblock %}</p>

<h3 id="如何解决:b466e8f2132e47affd6bf66f8fd23a0b">如何解决</h3>

<p>虽然加了一些简单判断，其实是没有解决实际问题。根据golang的flag包，程序需要保证只执行一次parse，但是在daemon的程序中，初始化的时候有可能直接中断程序，故也需要一些开关来判断在什么时候执行parse。 其他包则是在主函数中程序初始化完毕后，加载flag.Parse()即可解决。</p>

<p>包main:
{% codeblock lang:golang %}
func main(){
    &hellip;
    //基准包初始化
    base.Init()
    //数据包初始化
    data.Init()
    &hellip;
    //开始执行flag.Parse()
    var f *SFlag.Flag = SFlag.GetFlag()
    f.Parse()
    &hellip;
}
{% endcodeblock %}</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-fmt/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>Printf有一大堆这种转换，Go语言程序员把这些叫做verb（动词）。下面的表格列出了常用的动词，当然了不是全部，但基本也够用了。</p>

<p>%d          int变量
%x, %o, %b  分别为16进制，8进制，2进制形式的int
%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
%t          布尔变量：true 或 false
%c          rune (Unicode码点)，Go语言里特有的Unicode字符类型
%s          string
%q          带双引号的字符串 &ldquo;abc&rdquo; 或 带单引号的 rune &lsquo;c&rsquo;
%v          会将任意变量以易读的形式打印出来
%T          打印变量的类型
%%          字符型百分比标志（%符号本身，没有其他操作）</p>

<p>请注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-gc-crash/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>发现一个坑</p>

<p>坑的具体描述：由于程序有一个性能bug，会并发一直去数据池中取数据，而数据池中数据插入量少</p>

<p>最后问题是golang crash，抱错说内存找不到。</p>

<p>然后我debug 内存地址，发现在数据池中的时候，内存地址是存在的，等取出来内存地址为空。</p>

<p>至此怀疑是gc把内存清掉了。</p>

<p>最后解决办法： 解决性能问题，当数据池中无数据的时候，进程先停一下，不干活</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-gdb/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>#golang调试工具： GDB</p>

<p>使用  -gcflags &ldquo;-N -l&rdquo; 选项编译程序，这些选项阻止编译器使用内联函数和变量。</p>

<p>Demo:
go build -gcflags &ldquo;-N -l&rdquo; ./src/web/main.go</p>

<p>#安装相关
本地mac下的gdb不好使</p>

<p>先查看原GDB
which gdb
/usr/local/bin/gdb
ll /usr/local/bin/gdb
lrwxr-xr-x  1 root  wheel    27B  1 28  2015 /usr/local/bin/gdb -&gt; ../Cellar/gdb/7.7.1/bin/gdb</p>

<p>备份一下原GDB:
sudo mv /usr/local/bin/gdb /usr/local/bin/gdb7.7.1</p>

<p>下载最新的gdb
cd /usr/local/src/
sudo wget &lsquo;<a href="ftp://sourceware.org/pub/gdb/releases/gdb-7.9.tar.gz'">ftp://sourceware.org/pub/gdb/releases/gdb-7.9.tar.gz'</a></p>

<p>sudo tar -zxvf gdb-7.9.tar.gz
cd gdb-7.9
sudo ./configure
sudo make
sudo make install</p>

<p>这里查看最新的Gdb
<a href="ftp://sourceware.org/pub/gdb/releases/">ftp://sourceware.org/pub/gdb/releases/</a></p>

<p>///////&mdash;&ndash;
COYP:</p>

<p>gdb [options] &ndash;args executable-file [inferior-arguments &hellip;]</p>

<pre><code>l - 相当于list命令，l 37 显示37行附近的源码
b 行号，b 37 if i==3
b 函数名.函数名
i b - 查看全部断点信息
d - 删除所有断点
d 0 - 删除第0个断点
display a - 一直显示a的值
undisplay - 去掉所有显示
watch addr - 监控addr内存
s - step的意思进入函数进行跟踪
j 37 - 直接跳到37行运行
u - 将循环执行完
p a - 打印a的值
p a=3 - 设置a的值，p (*(mystruct *)addr) 打印一个数据结构，addr为其地址
r - 运行程序到断点
n - next的意思继续执行下一条语句
c - continue的意思，继续执行跳过当前断点， c 3 忽略3次断点
bt - 查看函数堆栈
where - 查看堆栈信息
up - 回溯一层堆栈
down - 到下一层堆栈
shell - 进入shell，如果再exit会回到gdb， shell echo $env
enable n - 开启第n个断点
disable n - 禁用第n个断点
finish - 执行本函数并返回
dir - 加目录
</code></pre>

<p>关闭GDB时，发现未退出应用程序：</p>

<p>a. 查找被占用的端口
netstat -tln
netstat -tln | grep 8060
netstat -tln 查看端口使用情况，而 netstat -tln | grep 8060 则是只查看端口8060的使用情况
b. 查看端口属于哪个程序？端口被哪个进程占用
lsof -i:8060</p>

<p>lsof -i:9000
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
revel 24739 yourihua 8u IPv6 576421 0t0 TCP *:9000 (LISTEN)</p>

<p>c.杀掉占用端口的进程 根据pid杀掉</p>

<p>kill -9 进程id
kill -9 24739</p>

<p>目的：使用gdb附加到一个正在运行的进程上，然后做一些调试，并安全退出。</p>

<ol>
<li><p>修改Ubuntu配置，允许gdb附加到进程上，如何修改如下：
<a href="http://askubuntu.com/questions/41629/after-upgrade-gdb-wont-attach-to-process">http://askubuntu.com/questions/41629/after-upgrade-gdb-wont-attach-to-process</a></p></li>

<li><p>查看进程id #ps ax 或者 #ps au</p></li>

<li><p>启动gdb</p></li>

<li><p>使用file命令来指定进程所联系的程序源代码和符号表，例如:</p></li>
</ol>

<p>file 要附加的源代码目录</p>

<ol>
<li><p>attach &lt;进程ID&gt;</p></li>

<li><p>打断点，如下：</p></li>
</ol>

<p>b path/to/app.go:10</p>

<ol>
<li><p>输入c，进程继续运行。</p></li>

<li><p>ctrl + c再次中断，回到gdb命令行，然后输入：deatch。
当你调试结束之后，可以使用该命令断开进程与gdb的连接(结束gdb对进程的控制)，在这个命令执行之后，你所调试的那个进程将继续运行。</p></li>
</ol>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-map-slice-pprof/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: golang map 、 slice性能对比
tags:
  - golang
  - pprof
  - 性能
  - 性能优化</p>

<h2 id="date-2015-05-07-17-51-12:334a929af4ce8f704f122454c602a299">date: 2015-05-07 17:51:12</h2>

<p>#todo</p>

<p>做了一次对比,查看map、slice之间的性能差距，由于golang底层对map、slice都是用array实现的，所以他们之间性能差距其实并不大</p>

<p>访问：<a href="http://localhost:6060/debug/pprof/">http://localhost:6060/debug/pprof/</a> 查看pprof</p>

<p>{% codeblock lang:golang %}
package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;log&rdquo;
    &ldquo;net/http&rdquo;
    _ &ldquo;net/http/pprof&rdquo;
    &ldquo;strconv&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>var run_count = 1000 * 10000 //千万长度</p>

<p>func main() {
    go func() {
        log.Println(http.ListenAndServe(&ldquo;localhost:6060&rdquo;, nil))
    }()
    //testMap()
    testSlice()
    for {
        fmt.Println(&ldquo;睡眠了2秒&rdquo;)
        time.Sleep(2e9)
    }</p>

<p>}</p>

<p>func testMap() {</p>

<pre><code>var m map[string]bool = make(map[string]bool)
for i := 0; i &lt;= run_count; i++ {
    m[strconv.Itoa(i)] = true
}
</code></pre>

<p>}
func testSlice() {</p>

<pre><code>var slice []string
for i := 0; i &lt;= run_count; i++ {
    slice = append(slice, strconv.Itoa(i))
}
</code></pre>

<p>}
{% endcodeblock %}</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-map/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>再来讲讲map这个数据结构，map是用make函数创建的数据结构的一个引用。当一个map被作为参数传递给一个函数时，函数接收到的是一份引用的拷贝，虽然本身并不是一个东西，但因为他们指向的是同一块数据对象（译注：类似于C++里的引用传递，实际上指针是另一个指针了，但内部存的值指向同一块内存），所以你在函数里对map里的值进行修改时，原始的map内的值也会改变。在我们的例子中，我们在countLines函数中插入到counts这个map里的值，在主函数中也是看得到的。</p>

<p>指针： Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，&amp;操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。我们会在2.3.2中进行详细介绍。</p>

<p>名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样；你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名。通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。</p>

<p>一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：</p>

<p><pre><code class="golang">
var f float32 = 16777216 // 1 &lt;&lt; 24
fmt.Println(f == f+1)    // &ldquo;true&rdquo;!
</pre></code></p>

<p>一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p>

<p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-pprof/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: golang 性能调优
tags:
  - golang
  - pprof
  - 性能
  - 性能优化</p>

<h2 id="date-2015-05-07-17-51-12:e3c7498059ef024bc3c5796944e785bc">date: 2015-05-07 17:51:12</h2>

<p>#todo</p>

<h1 id="对比性能提升:e3c7498059ef024bc3c5796944e785bc">对比性能提升</h1>

<p>Benchstat computes and compares statistics about benchmarks.
<a href="https://godoc.org/rsc.io/benchstat">https://godoc.org/rsc.io/benchstat</a></p>

<p>benchstat old.txt new.txt
name        old time/op  new time/op  delta
GobEncode   13.6ms ± 1%  11.8ms ± 1%  -13.31% (p=0.016 n=4+5)
JSONEncode  32.1ms ± 1%  31.8ms ± 1%     ~    (p=0.286 n=4+5)</p>

<h1 id="设置pprof:e3c7498059ef024bc3c5796944e785bc">设置pprof</h1>

<p><a href="https://godoc.org/github.com/pkg/profile">https://godoc.org/github.com/pkg/profile</a>
import&rdquo;github.com/pkg/profile&rdquo;
funcmain(){ deferprofile.Start().Stop() &hellip;
}</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-toml/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-xx/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>iota : 只在const中使用，类似计数器</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>把Go程序变小的办法是：
go build -ldflags &ldquo;-s -w&rdquo;  (go install类似)</p>

<p>解释一下参数的意思：
-ldflags： 表示将后面的参数传给连接器（5/6/8l）
-s：去掉符号信息（然后panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果）
-w：去掉DWARF调试信息。得到的程序就不能用gdb调试了</p>

<p>-s和-w也可以分开使用，一般来说如果不打算用gdb调试，-w基本没啥损失。
-s的损失就有点大了。</p>

<p>简单介绍了优化的几个方式：
channel,
defer,
refection,json,interface,
memroy{避免堆分配(用栈多用A{},而不是new(A))，pprof分析}
false sharing
<a href="http://www.yidianzixun.com/n/0D5GX1uR?s=3&amp;appid=xiaomi&amp;ver=3.6.0&amp;utk=18ucva67&amp;from=timeline&amp;isappinstalled=0">http://www.yidianzixun.com/n/0D5GX1uR?s=3&amp;appid=xiaomi&amp;ver=3.6.0&amp;utk=18ucva67&amp;from=timeline&amp;isappinstalled=0</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang_http_get_post/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: golang http get、post实例
tags:
  - golang
  - go</p>

<h2 id="date-2015-06-08-18-00-12:f073b65fa9169dea6fee5df40ae877d5">date: 2015-06-08 18:00:12</h2>

<p>生活中我们有很多代码格式是固定的，轮子造好后应该去创造其他东西，而不是重复造轮子。所以以下golang方式get、post做一个记录。以后可以直接copy使用</p>

<p>{% codeblock lang:golang %}
package main</p>

<p>import (
     &ldquo;fmt&rdquo;
     &ldquo;io/ioutil&rdquo;
     &ldquo;net/http&rdquo;
     &ldquo;net/url&rdquo;
     &ldquo;os&rdquo;
)</p>

<p>func main() {
     var sender = &ldquo;simonsun&rdquo;
     v := url.Values{}
     v.Set(&ldquo;type&rdquo;, &ldquo;tip&rdquo;)
     v.Add(&ldquo;sender&rdquo;, sender)
     v.Add(&ldquo;recvusers&rdquo;, sender)
     v.Add(&ldquo;message&rdquo;, &ldquo;骚年，你好content&rdquo;)
     v.Add(&ldquo;title&rdquo;, &ldquo;骚年，你好title&rdquo;)
     v.Add(&ldquo;pwd&rdquo;, &ldquo;123456&rdquo;)
     var url_info = &ldquo;<a href="http://rtx.oa.com:8013/service/index.php?&quot;">http://rtx.oa.com:8013/service/index.php?&quot;</a> + v.Encode()
     fmt.Println(url_info)
     //get 方式
     resp, err := http.Get(url_info)
     //post 方式
     //resp, err := http.PostForm(&ldquo;<a href="http://rtx.oa.com:8012/service/index.php&quot;">http://rtx.oa.com:8012/service/index.php&quot;</a>, v)
     if err == nil {
          body, err := ioutil.ReadAll(resp.Body)
          defer resp.Body.Close()
          if err == nil {
               fmt.Println(string(body))
               fmt.Println(err)
          } else {</p>

<pre><code>           fmt.Println(&quot;parse io read error&quot;, err)
      }
 } else {
      fmt.Println(&quot;http rtx error http error:&quot;, err)
 }
 os.Exit(1)
</code></pre>

<p>}
{% endcodeblock %}</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/how_to_be_a_good_programmer/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>be a good man
be a good programmer
be a good XXX</p>

<p>这本书能让你戒烟
这本书能让你XXX</p>

<p>然并卵[
    － 最差也能让人生更幸福
        － 影射，总有一款适合你
]</p>

<p>所有事情 道相通，术不同</p>

<p>大方向一致， 路不同</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/hugo/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>ategories = [&ldquo;Development&rdquo;, &ldquo;GoLang&rdquo;]
Description = &ldquo;&rdquo;
Tags = [&ldquo;Development&rdquo;, &ldquo;golang&rdquo;]
date = &ldquo;2015-09-23T16:30:37+08:00&rdquo;
menu = &ldquo;main&rdquo;
title = &ldquo;你好，Hugo&rdquo;</p>

<p>+++</p>

<p>这是使用Hugo创建的站点中的第一篇文章。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/idea/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>crawler v4</p>

<p>todolist:</p>

<p>前置条件：
data包
mk.log日志封装</p>

<p>analyze
down</p>

<p>//之后必须做的
mk/log日志file类封装</p>

<hr />

<p>千万级demo</p>

<p>web
web view
web api
file data cache
mk,mk.log</p>

<hr />

<p>撕逼大战[鹿晗到底是不是娘炮],话题大战<a href="争论完事线下交流">说说你到底有多爱鹿晗</a>
(争论入群－组织)</p>

<p>话题 平台
喷子 粉</p>

<p>价值  切入点 痛点</p>

<p>奇葩说 观点</p>

<p>奇葩说的价值是有的，而这个idea有价值么？ 跟贴吧有啥区别</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/iterm/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>分享一些关于iterm2 的快键键:</p>

<p>⌘ + Click：可以打开文件，文件夹和链接</p>

<p>⌘ + n：新建窗口</p>

<p>⌘ + t：新建标签页</p>

<p>⌘ + w：关闭当前页</p>

<p>⌘ + 数字 &amp; ⌘ + 方向键：切换标签页</p>

<p>⌥⌘ + 数字：切换窗口</p>

<p>⌘ + enter：切换全屏</p>

<p>⌘ + d：左右分屏</p>

<p>⇧⌘ + d：上下分屏</p>

<p>⌘ + ;：自动补全历史记录</p>

<p>⇧⌘ + h：自动补全剪贴板历史</p>

<p>⌥⌘ + e：查找所有来定位某个标签页</p>

<p>⌘ + r &amp; ⌃ + l：清屏</p>

<p>⌘ + /：显示光标位置</p>

<p>⌥⌘ + b：历史回放</p>

<p>⌘ + f：查找，然后用 tab 和 ⇧ + tab 可以向右和向左补全，补全之后的内容会被自动复制， 还可以用 ⌥ + enter 将查找结果输入终端</p>

<p>选中即复制，鼠标中键粘贴</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/javascript-cross-origin-resource-sharing/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: 造成跨域的原因，以及解决办法
tags:
  - javascript
  - 前端
  - ajax
  - 跨域</p>

<h2 id="date-2015-05-08-22-32-26:e84ba9cd4bce89fae3cefecd9c159f16">date: 2015-05-08 22:32:26</h2>

<p>今天同事过来问我一个问题：当js请求跨域的时候，服务器端能否接收到数据，如果能接收到数据是否是半链接？</p>

<p>我忽然发现我不知道改怎么回答这个问题，因为之前确实没有关注这个问题。</p>

<p>仔细想了一下并且查了相关资料做了测试结果为：</p>

<p>造成跨域的原因是js安全策略做的限制，http、浏览器是没有限制的。也就是说服务端是会有返回并且客户端也会接收数据只是js不认。</p>

<p>so重点是js，所以我们只要能绕过js安全策略即可。</p>

<p>基于这个，目前解决跨域问题的方法有如下：</p>

<p>设置domain</p>

<p>jsonp</p>

<p>form、iframe</p>

<p>cors</p>

<p>domain 这个使用最简单，使用频率也是最高的，同时限制也是很大的。它只能解决本域的跨域</p>

<p>jsonp 原理很简单，就是创建一个url地址去请求，然后返回的时候返回字符串内容，然后根据约定把返回的内容转换为js即可。jsonp使用频率很高，不过它的限制是不能post数据，所以不安全。</p>

<p>form、iframe 是很早之前使用的方式，在ajax之前就是用这个方法解决跨域的。介个很老了，现在很少用到它了</p>

<p>cors   这个是新解决办法，只需要在header里配置一下就可以解决跨域问题。很方便也很简单。不过由于比较新很多老浏览器不支持，下图是各个浏览器的支持情况。</p>

<p>&nbsp;</p>

<p><img src="/upload/javascript-cross-origin-resource-sharing.png" alt="" /></p>

<p><img src="/upload/javascript-cross-origin-resource-sharing2.png" alt="" /></p>

<p>网上介绍跨域的代码有很多，所以这里只写原理。代码就不重复造轮子了。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/learn_shell/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>##
 #   替换－最短的 从前面
 ##  替换－最长的 从前面
 %   替换－最短的 从后面
 %%  替换－最长的 从后面
例如：
echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin:/usr/local/go1.5.1/bin</p>

<p>echo ${PATH##/*:}
/usr/local/go1.5.1/bin</p>

<p>echo ${PATH#/*:}
/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin:/usr/local/go1.5.1/bin</p>

<p>##变量默认值设置</p>

<p>username=${username:-root}
如果username为空，则username为root
&gt; 注${username:-root}中冒号是有必要加的，如果不加则只要设置过username就不会再次覆盖，而加冒号后则只要username为空就更新变量.</p>

<p>##
Ctrl +C     终止目前的命令
Ctrl +D     输入结束 (EOF),例如邮件结束的时候;
Ctrl +M     就是 Enter 啦!
Ctrl +S     暂停屏幕的输出
Ctrl +Q     恢复屏幕的输出
Ctrl +U     在提示字符下,将整列命令删除
Ctrl +Z     『暂停』目前的命令</p>

<h1 id="shell中的正则:2429fbbfdb615ec24c1cf717adb9c98f">shell中的正则</h1>

<ul>
<li><p>通配符
? 一个字符
[] 和正则表达式一致</p>

<h1 id="注释:2429fbbfdb615ec24c1cf717adb9c98f">注释，</h1>

<p>\ 转义符
| 管道命令
; 连续指令分隔符,连续指令例如：sync; sync; shutdown -h now
~ 用户家目录
&amp; 后台运行
! not的意思
/ 目录符号
&gt;&gt; 、 &gt; 数据重导向
&lt;&lt;、&lt; 数据重导向
``、$() 优先执行的命令
() 子shell起始于结束</p></li>
</ul>

<h2 id="数据流重导向:2429fbbfdb615ec24c1cf717adb9c98f">数据流重导向</h2>

<p>*. 标准输入 (stdin):代码为0,使用&lt;、&lt;&lt;;
*. 标准输出 (stdout):代码为1,使用&gt;、&gt;&gt;;
*. 标准错误输出(stderr):代码为2,使用2&gt;、2&gt;&gt;;
&gt; 一个重定向的常用命令：cat &gt; catfile &lt;&lt; &ldquo;eof&rdquo;     ,当输入eof后，自动结束
一个shell三元命令示例：<br />
ls /tmp/vbirding &amp;&amp; echo &ldquo;exist&rdquo; || echo &ldquo;not exist&rdquo;</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/linux_command/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>软、硬链接区别：软链接为快捷方式，源删除后无法再打开。硬链接只能链文件，目录不可以。硬链接多份都为源，修改一处其他都变，删除多份也能打开.</p>

<p>od(octal dump) 命令可以以八进制、十进制、十六进制和ASCII码来显示文件或者流，它们对于访问或可视地检查文件中不能直接显示在终端上的字符很有用。
type、which 搜寻指令路径
whereis、locate(未搜索硬盘),它们的限制在于：如果文件未录入数据存档,那么则找不到.优势在于快，因为不搜索硬盘
    whereis [-bmsu] 档案或目录名
    选项与参数:
    -b : 只搜索binary文件
    -m : 只搜索manual路径下的文件
    -s : 只搜索source来源文件
    -u : 搜寻不在上述三个项目中的，其他特殊档案</p>

<pre><code>locate [-ir] keyword 
选项与参数:
-i : 省略大小写的差异
-r : 后面可接正则表示法的显示方式
</code></pre>

<p>find 233</p>

<p>df命令(page256)
    df [-ahikHTm] [目录或文件名]
    选项与参数:
    -a : 列出所有的文件系统,包括系统特有的 /proc 等文件系统;
    -k : 以 KBytes 的容量显示各文件系统;
    -m : 以 MBytes 的容量显示各文件系统;
    -h : 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示;
    -H : 以 M=1000K 叏代 M=1024K 的进位方式;
    -T : 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出;
    -i : 不用硬盘容量,而以 inode 的数量来显示
du命令(page258)
    du [-ahskm] 档案或目录名称
    选项与参数:
    -a : 列出所有的档案的目录容量,因为默认仅统计目彔底下的档案量而已。
    -h : 以人们较易读的容量格式 (G/M) 显示;
    -s : 列出总量而已,而不列出每个各别的目彔占用容量;
    -S : 不包括子目彔下的总计,与 -s 有点差别。
    -k : 以 KBytes 列出容量显示;
    -m : 以 MBytes 列出容量显示;
ln命令
    ln [-sf] 来源文件 目标文件
    选项与参数:
    -s : 如果不加任何参数就进行硬连结,那就是 hard link,至于 -s 就是 symbolic link
    -f : 如果 目标文件 存在时,就主动的将目标文件直接移除后再建立!</p>

<p>fdisk(page264)
mkfs(page271)
fsck(filesystem check)(page274) 用来检验文件系统是否出错
badblocks 用来检查硬盘或软盘扇区有没有坏轨
mount(page275)
开机挂载 /etc/fstab 及 /etc/mtab (page284)
swap 设置(page289)</p>

<p>cut命令(page400)
    cut[-dfc]
    选项与参数:
    -d : 后面接分隔符，配合-f一起使用
    -f : 依据－d的分隔符将一段信息分割成数段，－f为第几段的意思
    -c : 根据范围[cut -c 2-4]取内容</p>

<p>grep命令(page401)
    grep [-acinv] [&ndash;color=auto]
    选项与参数:
    -a :将 binary 档案以 text 档案的方式搜寻数据
    -c :计算找到&rsquo;搜寻字符串&rsquo; 的次数
    -i :忽略大小写的不同,所以大小写规为相同
    -n :顺便输出行号
    -v :反向选择,亦即显示出没有 &lsquo;搜寻字符串&rsquo; 内容的那一行
    &ndash;color=auto :可以将找刡的关键词部分加上颜色的显示
&gt; 例如：cat file_name.log |cut -c 29-44|sort -u :取tlog唯一主键</p>

<p>sort命令(page402)
     sort [-fbMnrtuk] [file or stdin]
    选项与参数:
    -f :忽略大小写
    -b :忽略最前面的空格
    -M :以月份的名字来排序
    -n :以纯数字排序
    -r :反向排序
    -u :就是uniq，唯一去重
    -t :分隔符,(默认是tab分割)
    -k :以那个区间(field)来进行排序
&gt; 例如：ls -l |sort  -k 5 -n -r |head :列出最大的几个文件
uniq 命令,(sort -u就可以做到)
    uniq [-ic]
    选项与参数:
    -i :忽略大小写
    -c :进行计数</p>

<p>wc命令(page404)
    wc [-lwm]
    选项与参数:
    -l :仅列出行
    -w :仅列出字数
    -m :多少字符
tee命令(page405),同时写入文件并输出到屏幕
    tee [-a] file
    选项与参数:
    -a : append方式写入文件
字符转换(page405)tr, col, join, paste, expand</p>

<p>split命令(page404)
    split [-bl]
    选项与参数:
    -b :欲分割的大小
    -l :以行数分割
&gt; 例如split -l 30000 file_name file_name_split
&gt; 合并：cat file_name_split* &gt;&gt; filename
&gt; ls -al / | split -l 10 - lsroot,重点在[最后一个-]这里，意思为stdin、stdout</p>

<p>xargs命令(page410)
    xargs [-0epn] command
    选项与参数:
    -0 :如果stdin输入有特殊字符，用-0还原为一般字符
    -e :EOF(end of file)的意思，后面接一个字符串，当xargs分析到这个字符串时就会停止。
    -p :每次都询问用户
    -n :后面接次数，每次执行时，要使用几个参数
    - :
    - :</p>

<h1 id="正则表达式-12章咱不纪录:5641cb59b7d79ad15177a6eb585d16a6">正则表达式-12章咱不纪录</h1>

<pre><code> grep、sed、awk、diff、cmp、patch、pr

 sed - 取ip地址：
 ifconfig en0|grep inet\ |sed 's/inet\ //g'|sed 's/ netmask.*$//g'
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/linux_linux_shell_read/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: 巧用read 让你的shell更人性化
tags:
  - linux
  - shell</p>

<h2 id="date-2015-05-08-23-21-34:6103025f5c157eb969259e45447f98c8">date: 2015-05-08 23:21:34</h2>

<p>先来张图热乎一下：
<a href="/wp-content/uploads/2015/05/7DF97234-0661-465F-8256-51D0809709DF.png"><img src="http://dev.blog.simonsun.net/wp-content/uploads/2015/05/7DF97234-0661-465F-8256-51D0809709DF.png" alt="7DF97234-0661-465F-8256-51D0809709DF" /></a></p>

<p>我们使用shell read让shell更人性化，使用方便还高大上。
read使用方式很简单， 直接［read 变量］ 即可</p>

<p>来个demo：</p>

<p>{% codeblock lang:bash %}
#!/bin/bash
read -p “Enter your name:” name
echo “hello $name, welcome to my program”
exit 0
{% endcodeblock %}</p>

<p>具体参数</p>

<p>Read可以带有-a, -d, -e, -n, -p, -r, -t, 和 -s八个选项。
-a ：将内容读入到数值中
{% codeblock lang:sh %}
echo -n “Input muliple values into an array:”
read -a array
echo “get {$#array[@]} values in array”
{% endcodeblock %}</p>

<p>-d ：表示delimiter，即定界符，一般情况下是以IFS为参数的间隔，但是通过-d，我们可以定义一直读到出现执行的字符位置。例如read –d madfds value，读到有m的字符的时候就不在继续向后读，例如输入为 hello m，有效值为“hello”，请注意m前面的空格等会被删除。这种方式可以输入多个字符串，例如定义“.”作为结符号等等。</p>

<p>-e ：只用于互相交互的脚本，它将readline用于收集输入行。读到这几句话不太明白什么意思，先跳过。</p>

<p>-n ：用于限定最多可以有多少字符可以作为有效读入。例如echo –n 4 value1 value2，如果我们试图输入12 34，则只有前面有效的12 3，作为输入，实际上在你输入第4个字符‘3’后，就自动结束输入。这里结果是value为12，value2为3。</p>

<p>-p ：用于给出提示符，在前面的例子中我们使用了echo –n “…“来给出提示符，可以使用read –p ‘… my promt?’value的方式只需一个语句来表示。</p>

<p>-r ：在参数输入中，我们可以使用’/’表示没有输入完，换行继续输入，如果我们需要行最后的’/’作为有效的字符，可以通过-r来进行。此外在输入字符中，我们希望/n这类特殊字符生效，也应采用-r选项。</p>

<p>-s ：对于一些特殊的符号，例如箭头号，不将他们在terminal上打印，例如read –s key，我们按光标，在回车之后，如果我们要求显示，即echo，光标向上，如果不使用-s，在输入的时候，输入处显示^[[A，即在terminal上 打印，之后如果要求echo，光标会上移。</p>

<p>-t ：用于表示等待输入的时间，单位为秒，等待时间超过，将继续执行后面的脚本，注意不作为null输入，参数将保留原有的值</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/mac-soft/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>iterm2
command + shift+d     水平分隔窗口
command + d           垂直分隔窗口
command + ?           显示光标位置
command + ;           自动补全命令
command + shift +h    显示历史记录</p>

<p><a href="http://www.cnblogs.com/chijianqiang/p/alfred.html">http://www.cnblogs.com/chijianqiang/p/alfred.html</a>
<a href="http://chijianqiang.baijia.baidu.com/article/3733">http://chijianqiang.baijia.baidu.com/article/3733</a>
<a href="http://www.macx.cn/thread-1933000-1-1.html">http://www.macx.cn/thread-1933000-1-1.html</a></p>

<p>Ack—比grep要好
Autojump—目录导航
Command-t—用于模糊查询的vim插件；（点击链接了解如何在tmux中设置）
Pandoc—格式转换
Poweline-vim—定制vim状态栏
Pianobar—终端Pandora 音乐播放器
pdfgrep—PDF文件的grep
shelr—shell中的屏幕录制工具
vimux—用vim与tmux交互
virtualenv—Python虚拟环境创建工具
wemux—多用户终端共享器
yadr—一套zsh，MacVim，和git 的配置文件</p>

<p>#zsh
alias -s html=mate，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取 hello.html； alias -s gz=&lsquo;tar -xzvf&rsquo;，表示自动解压后缀为 gz 的压缩包。</p>

<p>#autojumb
brew install autojump
<a href="http://macshuo.com/?p=676">http://macshuo.com/?p=676</a></p>

<h4 id="有关学习的:560621505799f89008152394bcda8a1e">有关学习的</h4>

<p>豆瓣上有个小组开发了一款叫 Kindle Mate的PC端软件，这款软件有多牛呢？连接kindle后它可以导出所有的生词本，笔记，注释，而且可以根据书籍、作者对标注笔记和生词本进行自动整理分类。这是我电脑上的kindle mate截图：</p>

<p>柯林斯词典有一个高达2.5亿的语料库，从语料库中筛选出了最常用的14600词用五星标注。其中五级（最常用词，以下逐级次之）680词，四级1040词（累计1720词），三级1580词（累计3300词），二级3200词（累计6500词），一级8100词（累计14600词）。根据语料库的统计结果，掌握五级四级的前1720詞，就可以读通英語资料的75%，掌握五、四、三、二級的6500詞，就可以读通英語资料的90%，掌握这14600詞，就可以读懂任何英語资料的95%，即从理论上说，任何一篇100词的文章里大概只有5个词不认识。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/markdown-desc/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: markdown快速上手笔记
tags:
  - markdown</p>

<h2 id="date-2015-09-06-17-07-34:fbdb0d457e99d0a42b2d74d55f5d25f8">date: 2015-09-06 17:07:34</h2>

<h1 id="前言:fbdb0d457e99d0a42b2d74d55f5d25f8">前言</h1>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>

<h1 id="一级标题:fbdb0d457e99d0a42b2d74d55f5d25f8">一级标题</h1>

<h2 id="二级标题:fbdb0d457e99d0a42b2d74d55f5d25f8">二级标题</h2>

<h3 id="三级标题:fbdb0d457e99d0a42b2d74d55f5d25f8">三级标题</h3>

<h4 id="四级标题:fbdb0d457e99d0a42b2d74d55f5d25f8">四级标题</h4>

<p>#列表
列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。</p>

<p>###无序列表
- -列表
- -列表
* *列表
* *列表
+ +列表
+ +列表</p>

<p>###有序列表
1. 1列表
2. 2列表</p>

<p>#引用
&gt; 例如这样</p>

<p>###粗体与斜体</p>

<p>Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。</p>

<p><strong>粗体</strong> <em>斜体</em></p>

<p>代码框</p>

<p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来，如 <code>code</code>。图例：</p>

<p><code>
    funciton abc(name int){
        fmt.Println(&quot;helo world&quot;)
    }
</code></p>

<p>分割线</p>

<p>分割线的语法只需要另起一行，连续输入三个星号 *** 即可。</p>

<p>＃图片
<img src="/upload/javascript-cross-origin-resource-sharing2.png" alt="" />
<a href="http://www.baidu.com/">地址</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/mk/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>#MK框架需要做的</p>

<p>core:
共用的IncreaseErrors</p>

<p>route:
                                                                 正则格式的路由
                                                                 自定义路由[比如/api映射到/wechat/notify]
url path设置 /group/controller/action/path/path/path
路由出错不是panic 应该是increaseErrors</p>

<p>mk/web/core/request
                                                                增加默认数据</p>

<pre><code>                                                            //
                                                            // 这里不做增加默认数据功能了，
                                                            // 原因是：会用到反射或panic。并且会有error情况。得不偿失
                                                            // @ date 2016-04-06 16:37:01
                                                            // @ author simonsun
                                                            //
                                                            h.Get(string).Default(interface{}).Int64()
                                                            var openid int64 = h.Get(&quot;openid&quot;).Default(333).Int64()
                                                            var openid int64 = h.Get(&quot;openid&quot;,nil).Int64()
                                                            var openid int64 = h.Get(&quot;openid&quot;,333).Int64()
</code></pre>

<p>Redirect 设置
h.Redirect</p>

<hr />

<p>todo 有时间再做的：</p>

<p>auth
upload file
data接入到mk.v2中</p>

<pre><code>type DataTest struct{
    UserName string `Data:&quot;FilterTrimSpace;VerifyRequired&quot;,From:&quot;user_name&quot;,json:&quot;uname&quot;`
}

var d data.Data 
var err error
d,err= h.NewData(&amp;DataTest{})
or
d,err:=h.NewData(&amp;DataTest{})

d.HasError()

</code></pre>

<p>定义timeout、max header等</p>

<pre><code>func main() {
    router := gin.Default()

    s := &amp;http.Server{
        Addr:           &quot;:8080&quot;,
        Handler:        router,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }
    s.ListenAndServe()
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/open-source-desc/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>#六大开源许可证之间的区别</p>

<p>如何为代码选择开源许可证，这是一个问题。</p>

<p>世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种&mdash;-GPL、BSD、MIT、Mozilla、Apache和LGPL&mdash;-之中做选择，也很复杂。</p>

<p>乌克兰程序员Paul Bagwell(<a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses)，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。">http://pbagwl.com/post/5078147450/description-of-popular-software-licenses)，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。</a></p>

<p>下面是我制作的中文版，请点击看大图。</p>

<p>{{ % img src=&ldquo;/upload/open-source-distinction.png&rdquo; alt=&ldquo;六大开源许可证之间的区别&rdquo; %}}</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/soft/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>链家－吕毅：</p>

<p>同学们，咨询个问题。go有没有现成的视频转码方案。就是我们的用户上传了个高清的avi视频，我们通过技术方案把他转码为几个低分辨率的其他格式的视频。go或者非go的方案都成</p>

<p>业界大多都是ffmpeg
opencv 牛刀杀鸡 - 说明opencv牛逼</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/success/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>就象很多开发中的最佳实践一样，用正确的方法去做正确的事情会为开发节省大量的时间。
紧张意味着“怕”，可以输，但不能被吓死。</p>

<p>每个语言都有精华部分，也有鸡肋部分（鸡肋无法避免），，，作为一个优秀的程序员就是要取其精华，去其糟糠之处。</p>

<p>我们的的视野决定了我们的人生</p>

<p>有两种方式构建软件设计：一种是把软件做得很简单以至于明显找不到缺陷；另一种是把它做得很复杂以至于找不到明显的缺陷。</p>

<p>真正的工程师是能真正明白软件开发不单单只是coding，还更要明白整个软件工程。只明白或是只喜欢coding的，那只是码农，不能称之为工程师。</p>

<p>我们在尝试新的事物的时候，总是会越到各种各样的困难，不同的人会在碰壁不同的次数之后退出。用程序员喜欢的话来说就是，我们都在for循环，区别在于你是什么情况下break;的。有的人退出阈值高，这是能坚持的一类人；有的人退出阈值低，这类人很可能遇到一些障碍就退出了。</p>

<p>良好的判断力来源于经验</p>

<p>我们错误的关注于解决方案而非问题本身，
good judgment  comes   from
而经验则来自失败的教训
experience and all of that comes from bad judgment</p>

<p>”一个卓越的车床工可以要求比一个一般的车床工多拿数倍高的工资，但一个卓越的软件写手的价值会10000倍于一个普通的写手。“ — — 比尔 盖茨</p>

<p>程序是写给人读的，只是偶尔让计算机执行一下</p>

<p>循序渐进才能赢得时间，细水长流才能直达永恒！</p>

<p>100次心动不如一次行动，一个实干者胜过100个空想家。</p>

<p>我们每天读的书，会积累下来，影响我们的每一天。久而久之，我们会惊讶的发现，我们读过的书深植于心，改变着我们的人生</p>

<p>如果你想好好利用时间，你就得知道什么最重要，然后全力以赴去做这件事。</p>

<p>我们不找时间，不挤时间；我们只是安排时间，利用时间。</p>

<p>事实上，人人都能为他们选择去做的事情腾出时间；真正缺乏的不是时间，而是意愿。</p>

<p>你的梦想伤害了很多人，因为他们没有梦想。</p>

<p>大脑运转原则：GI-GO 输入垃圾，输出垃圾 Garbage in，Garbage out</p>

<p>训练有素之头脑,皆以最大限度把握事物本质为满足,不屑对一切细微末节穷追不舍.&ndash;亚里士多德</p>

<p>境遇只是境遇，它是中性的，关键取决于我们如何看待它。</p>

<p>一青年换了许多工作，找禅师抱怨：“我不喜欢重复。”禅师：“佛祖一生，都在重复讲他在菩提树下的觉悟。人这一生，如用1%力气选择，99%用心重复，每次都能感受新鲜的力量。如用99%力气选择，1%重复，他只能不断重复失败。”
悟：简单事情重复做，你就是专家。重复事情用心做，你就是赢家！</p>

<p>中信</p>

<p>6226 9007 1510 4150 6226900715104150</p>

<p>光大</p>

<p>6226 6202 0253 7056   6226620202537056</p>

<p>北京：</p>

<p>6210305003182975             6210 3050 0318 2975（北京银行红星支行）</p>

<p>工商银行：6222 0202000 39308644           6222020200039308644</p>

<p>户名：张欢欢 望京青年沟路储蓄所，网点号2303(230230198802191127) 57015821 中国工商银行和平里北街支行</p>

<p>您编号为9991429508696的申请已成功提交</p>

<p>建行：6217 0000 1002 3429 320     6217000010023429320 航华科贸支行</p>

<p>jo..7..simo  3568 9600 0059 1514</p>

<p>ceci:20130831q..</p>

<p>6222 6009 1004 4272 910 公积金</p>

<p>6222020902006862392 李秀华</p>

<p>6221 8826 0006 5172 013 孙国庆 邮政（克东县保安街支行 （折6026 5100 2200 4067 53 ））</p>

<p>北京久游科技有限公司</p>

<p>北京朝阳门外悠唐国际写字楼B座12层 住哪网（丰联广场南100米）</p>

<p>昌平区北七家镇八仙别墅仙霞东里0207号楼4层0807
123158</p>

<p>孙艳明，13681467020，， 北京 北京市 朝阳区 北京市朝阳区国贸建外soho东区9号楼1602，100004</p>

<p>index.php/NewsClass/clist/id/$%7B@phpinfo%28%29%7D</p>

<p>211.99.249.162
p.1m.2c.3n.4!@#</p>

<p>github:</p>

<p>id:4664919</p>

<p>pw:bidhje</p>

<p>email:4664919@qq.com</p>

<p>milnk.com：</p>

<p>id:4664919</p>

<p>email:4664919@qq.com</p>

<p>110010842049
2408201556575678
北京朝阳区国贸建外soho东区9号楼1602</p>

<p>simon_svn_user23ccfb0e22d39f31a0286d89339e7759</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/utf8-%E5%AD%97%E8%8A%82-unicode/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>关于字符集 utf8，和字节，的说明</p>

<p><a href="http://my.oschina.net/goal/blog/195749">http://my.oschina.net/goal/blog/195749</a>
<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a>
<a href="http://cenalulu.github.io/linux/character-encoding/">http://cenalulu.github.io/linux/character-encoding/</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/vim_install/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>安装vim golang
<a href="http://tonybai.com/2014/11/07/golang-development-environment-for-vim/">http://tonybai.com/2014/11/07/golang-development-environment-for-vim/</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/vim_practical/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: vim 实用技巧
tags:
  - vim
  - 编辑器</p>

<h2 id="date-2015-11-09-15-12-06:1069001ad9ca1b142047d5777a43fc05">date:2015-11-09 15:12:06</h2>

<p>#＃ vim编辑器号称编辑器之神，在编辑上有其无与伦比的编辑功能。但是在平时的使用中很多高效的技巧并没有使用。这里记录一些高效技巧，让我们编辑速度在提升一个台阶！</p>

<ol>
<li>.在编辑中的用处
.这个功能很强，为重复上一次的修改。.其实是一个微型的宏。
gif＝显示.的威力
其他： f命令－f{char} 查找字符，并跳转到{char}位置
       ; 和f{char}对应，跳转到f的下一个位置
       , 和;对应，回跳转到上一个;号位置</li>

<li><p>daw 用处
daw 删除一个词
gif ＝</p></li>

<li><p><C-a>,<C-x> 对数字进行加减操作
会自动找到当前行内的第一个数字，并对其相加减。加减包括8进制、10进制、16进制</p></li>
</ol>

<h2 id="插入模式:1069001ad9ca1b142047d5777a43fc05">插入模式</h2>

<blockquote>
<blockquote>
<blockquote>
<p>盲打的时候并不是仅仅不看键盘，还意味着输入的时候要凭感觉。当盲打错误时，在屏幕输出错误之前他们就已经察觉到了，他们可以凭手指感觉这类错误</p>
</blockquote>
</blockquote>
</blockquote>

<p>1.删除字符： <C-h> 删除一个字符，<C-w> 删除一个词 ， <C-u> 删除至行首
2.运算：<C-r>=3*338<CR></p>

<p>vit:选中标签内部的内容
Vr-:替换整行内容为-
写入行末尾 <C-v>jj$ A
    //page:46 技巧10
    //page:61 技巧20
    //page:74 技巧27</p>

<p>EX命令 －</p>

<p>:help <C-r><C-w> 命令，没整明白
反正有个牛逼的功能:使用*号会高亮关键字，然后使用:%s//xxx/g直接不用关键字就可以替换了</p>

<p>回溯历史－history和q:两个，觉得没个球用，page:90</p>

<p>使用!来执行shell命令，也可 使用:shell 进入命令行</p>

<p>#第二部分 －文件</p>

<h2 id="管理多个文件:1069001ad9ca1b142047d5777a43fc05">管理多个文件</h2>

<p>:ls - 查看当前缓冲区文件列表
切分窗口： 切分窗口会共用一个缓冲区。这个很有用
<c-w>s －水平窗口
<c-w>v －垂直窗口</p>

<dl>
<dt>:vsp[lit] {file} - 垂直切分窗口，并把文件载入缓冲区</dt>
<dt>:close 关闭窗口
:only 关闭其它窗口
:tabcolse关闭当前窗口
:tabonly关闭其它窗口
gt=下一个窗口,[N]gt 切换到编号为N的标签页 , ex:tabnext
gT=上一个窗口,ex:tabprevious
:tabmove [id]挪动标签页，id为0就挪到开头,如果没提供就挪到页尾
可以把当前窗口移动到一个新的标签页中。如果当前标签页中有多个窗口。</dt>
</dl>

<p>个新的标签页中。如果当前标签页中有多个窗口。</p>

<h2 id="打开及保存文件:1069001ad9ca1b142047d5777a43fc05">打开及保存文件</h2>

<p>114-技巧41，没看懂</p>

<p>#第三部分 －更快的移动
    gj,gk 按照屏幕行进行上下移动，很赞
    g0 移动到屏幕行行首
    g^ 移动到屏幕行第一个非空字符
    g$ 移动到屏幕行行末尾</p>

<h2 id="移动单词:1069001ad9ca1b142047d5777a43fc05">移动单词</h2>

<pre><code>w、b、e、ge - 移动字串到首尾
W、B、E、gE - 移动单词到首尾
</code></pre>

<h2 id="对字符进行查找:1069001ad9ca1b142047d5777a43fc05">对字符进行查找</h2>

<pre><code>f{char} F{char}
t{char} T{char}
; 重复上次的查找命令
, 反向查找
</code></pre>

<h2 id="通过查找进行移动:1069001ad9ca1b142047d5777a43fc05">通过查找进行移动</h2>

<pre><code> /{chars} n N 进行查找    
</code></pre>

<h2 id="对象选区-参看142-表8-1:1069001ad9ca1b142047d5777a43fc05">对象选区 参看142，表8-1</h2>

<pre><code>vi{, di{,di( 你懂的
va
cit:会删除当前a标签下的&quot;s&lt;i&gt;123&lt;/i&gt;ss&quot;   &lt;a href=&quot;sdfsdf/urlsdfsdfhh&quot;&gt;s&lt;i&gt;123&lt;/i&gt;ss&lt;/a&gt;
b=(,B={   例如vab=va(,vabB=va{
}
</code></pre>

<h2 id="删除周边修改内部-参看144-表8-2:1069001ad9ca1b142047d5777a43fc05">删除周边修改内部 参看144，表8-2</h2>

<pre><code>ciw,caw,caW,caE,cae .... 各种组合
iw
aw
iW
aW
is
as
ip
ap
</code></pre>

<h2 id="设置位置标记-方便快速跳回-参看147-表8-3:1069001ad9ca1b142047d5777a43fc05">设置位置标记，方便快速跳回 参看147，表8-3</h2>

<pre><code>m{a-zA-Z} 来标记
``命令，碉堡了， 上次跳转动作之前的命令
`.
`^
`[
`]
`&lt;
`&gt;
</code></pre>

<h2 id="在匹配括号之间跳转:1069001ad9ca1b142047d5777a43fc05">在匹配括号之间跳转</h2>

<pre><code> % 命令允许我们在开、闭括号间跳转。用于(){}[]
</code></pre>

<h2 id="在文件间跳转:1069001ad9ca1b142047d5777a43fc05">在文件间跳转</h2>

<pre><code> &lt;C-o&gt; 像后退按钮
 &lt;C-i&gt; 像前进按钮
 它们本身不会被当作命令
</code></pre>

<p>m{mark} 的威力</p>

<h1 id="第四部分-寄存器:1069001ad9ca1b142047d5777a43fc05">第四部分 寄存器</h1>

<h2 id="复制与粘贴:1069001ad9ca1b142047d5777a43fc05">复制与粘贴</h2>

<p>复制 yank
粘贴 put
删除 delete</p>

<pre><code>//page:160
</code></pre>

<h1 id="vim-插件:1069001ad9ca1b142047d5777a43fc05">vim 插件</h1>

<h3 id="增强的-功能插件matchit:1069001ad9ca1b142047d5777a43fc05">增强的%功能插件matchit</h3>

<p>runtime macros/matchit.vim</p>

<h3 id="给文本增加分隔符的插件surround:1069001ad9ca1b142047d5777a43fc05">给文本增加分隔符的插件surround</h3>

<p>Plugin &lsquo;<a href="https://github.com/tpope/vim-surround'">https://github.com/tpope/vim-surround'</a></p>

<h2 id="不加载任何插件启动vim:1069001ad9ca1b142047d5777a43fc05">不加载任何插件启动vim</h2>

<p>vim -u NONE -N practical_vim.rb</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/vim_vim_search_ag-vim/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: vim搜索插件ag.vim
tags:
  - vim
  - ag.vim
  - VIM插件</p>

<h2 id="date-2015-06-08-18-02-29:faf9a81c7f392511c11f9c5178888411">date: 2015-06-08 18:02:29</h2>

<div>之前使用vim搜索特别麻烦，vim自带的vimgrep速度慢，而且不好用。</div>
<div></div>
<div>先安装 the_silver_searcher</div>
<div>brew install the_silver_searcher</div>
<div></div>
<div>vim下配置：</div>
<div>Bundle &#8216;[https://github.com/rking/ag.vim](https://github.com/rking/ag.vim)&#8216;</div>
<div>let g:ackprg = &#8216;ag &#8211;nogroup &#8211;nocolor &#8211;column&#8217;</div>
<div></div>
<div></div>
<div>git地址传送门</div>
<div>[https://github.com/rking/ag.vim](https://github.com/rking/ag.vim)</div>
<div></div>
<div></div>
<div></div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/web-security-hack/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: 一次网站劫持排查
tags:
  - security
  - 安全
  - web安全
  - 网站劫持</p>

<h2 id="date-2015-10-15-17-00-14:bc8f651661e60ea7572437c49724694d">date: 2015-10-15 17:00:14</h2>

<p>今天一个朋友找我排查一个安全问题，在此做下记录
问题描述：网站直接打开正常，但是通过百度（搜索引擎）过来的就会跳转到钓鱼网站。</p>

<p>猜测可能出现的问题：
    1.dns被劫持(域名劫持)
    2.网站被注入
    3.xss等漏洞</p>

<p>解决过程：
先看是否能够在我自己电脑重现：
可以重现，说明不是dns被劫持。</p>

<p>查看百度跳转链接返回内容：
{% codeblock lang:html %}
<meta content="always" name="referrer"><script>try{if(window.opener&amp;&amp;window.opener.bds&amp;&amp;window.opener.bds.pdc&amp;&amp;window.opener.bds.pdc.sendLinkLog){window.opener.bds.pdc.sendLinkLog();}}catch(e) {};var timeout = 0;if(/bdlksmp/.test(window.location.href)){var reg = /bdlksmp=([^=&amp;]+)/,matches = window.location.href.match(reg);timeout = matches[1] ? matches[1] : 0};setTimeout(function(){window.location.replace(&ldquo;<a href="http://www.pvnews.cn/chanyeyaowen/2015-10-15/127821.html&quot;)},timeout">http://www.pvnews.cn/chanyeyaowen/2015-10-15/127821.html&quot;)},timeout</a>);</script>
<noscript><META http-equiv="refresh" content="0;URL='http://www.pvnews.cn/chanyeyaowen/2015-10-15/127821.html'"></noscript>
{% endcodeblock %}
没发现异常。</p>

<p>到此怀疑应该是服务器被黑了，因为这种只有服务器端js或程序做判断才能做到。
设置Referer来源：</p>

<p>{% codeblock lang:shell %}
curl &lsquo;<a href="http://www.pvnews.cn/chanyeyaowen/2015-10-15/127821.html'">http://www.pvnews.cn/chanyeyaowen/2015-10-15/127821.html'</a> -e &lsquo;<a href="http://www.baidu.com/link?url=-AX3MaL4C0KwhQkt4Nk0PqHj4qIkrKZQn4ZZz7sL0_cdIYjRCqVYB5BemgBK2LjyDKZ9L3GpvFhnYm2ItWWGE_&amp;wd=&amp;eqid=b4698ab60000ca7200000003561f80f2'">http://www.baidu.com/link?url=-AX3MaL4C0KwhQkt4Nk0PqHj4qIkrKZQn4ZZz7sL0_cdIYjRCqVYB5BemgBK2LjyDKZ9L3GpvFhnYm2ItWWGE_&amp;wd=&amp;eqid=b4698ab60000ca7200000003561f80f2'</a>
{% endcodeblock %}</p>

<p>经过diff返回与正常网页没有区别.</p>

<p>最终查看js,发现如下代码：
{% codeblock lang:js %}
if(window.name != &lsquo;ad_app6&rsquo;){</p>

<pre><code>var r = document.referrer;

r = r.toLowerCase();

var aSites = new Array('google.','baidu.','soso.','so.','haosou.','yahoo.','youdao.','sogou.','gougou.');

var b = false;

for (i in aSites){

    if (r.indexOf(aSites[i]) &gt; 0){

        b = true;

        break;

    }

}



if(b)

{

    self.location = 'http://www.laok.cc/#老K全讯网';

    window.adworkergo = 'ad_app6';

}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}
至此查到问题所在，服务器被黑,或ftp之类的被破</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/why-write-blog/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>title: 首篇博客说明 以及为什么写博客
tags:
  - 未分类</p>

<h2 id="date-2015-05-07-17-19-46:fa5cfe609126a25636eefc277e3149c5">date: 2015-05-07 17:19:46</h2>

<p>断断续续写了几年的博客，每个阶段的开始也是一个新博客的开启。期望不会再变动博客了，之前写的博客会酌情挪动到此博客下，一些质量不高的就抛弃了。</p>

<p>关于为什么写博客，之前博客盛行一时到之后的衰落，我当年也是跟风写了一点。由于各种原因博客总是断掉，其中最重要的原因是当时不知道博客存在的价值。直到读《暗示间》、《把时间当作朋友》（不记得到底是哪一本了）时才知道博客的核心价值。这也是我重新写博客的原因和动力。</p>

<p>那么博客的核心价值是什么呢？ 个人觉得主要是减少沟通成本。其他人想了解我们可以通过观看我们的博客从而了解我们，而我们博客只写一次可以让所有人来观看。</p>

<p>其次我们自己也可以通过观看自己的博客了解曾经的我们的所知所想。</p>

<p>最后，曾经用过wordpress，后来觉得不好用，放弃了。结果最后还是用它了。新版的wordpress很好用！～</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/xidi-golang-build-/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>#喜地golang服务编译规范</p>

<p>##前置条件
 - GOPATH:必须注册两个，一个为第三方lib库，另一个为喜地lib库
 - 每个服务有自己的lib库，统一在[服务/trunk/src/服务名称/包名称] 下
 - 服务格式固定-参见目录格式说明</p>

<h2 id="当前-自动化部署之前-上线流程:81d141d7a260742581a285f0fa97e1c1">当前[自动化部署之前]上线流程</h2>

<ul>
<li>首先把当前服务所属目录注册到GOPATH中-参见注册gopath</li>
<li>开始编译</li>
<li>部署到服务器</li>
<li>停止服务器上在运行的服务</li>
<li>升级到最新部署的服务</li>
<li>启动服务器上的服务</li>
</ul>

<p>#附录一些结构和shell说明;</p>

<p>####注册gopath：
<pre>
#!/bin/bash
CURDIR=<code>pwd</code>
OLDGOPATH=&ldquo;$GOPATH&rdquo;
export OLDGOPATH=&ldquo;$GOPATH&rdquo;
echo &ldquo;Your GOPATH is:&rdquo;
GOPATH=&ldquo;$GOPATH:$CURDIR&rdquo;
export GOPATH
echo &ldquo;Now GOPATH is: $GOPATH&rdquo;
echo &lsquo;Finished&rsquo;
</pre></p>

<p>####目录格式说明:
<pre>
├──                                     －－服务根目录
└── trunk                               －－服务的分支
    ├── bin                             －－二进制文件目录
    │   └── {$NAME}                     －－最新版本二进制分发文件
    │   └── {$NAME}.v.1&hellip;.             －－历史版本二进制分发文件
    ├── data                            －－数据文件夹，生产环境下，根据不同服务配置此目录可能不与bin同级(比如会放到/var/log/xidibuy/下)
    │   ├── conf                        －－配置文件目录
    │   │   └── config.toml             －－配置名称
    │   │   └── config.xxxx             －－其它配置或历史配置
    │   ├── static                      －－静态文件目录，非必须存在
    │         &hellip;.                      －－其它目录，例如：view,log&hellip;.
    │         &hellip;.
    ├── pkg                             －－编译生成的pkg
    ├── src                             －－go代码源文件目录
    │   ├── {$NAME}                     －－服务名称
    │   │   ├── config                  －－当前服务所属的子包
    │   │   ├── controller              －－当前服务所属的子包
    │   │   ├── &hellip;<br />
    │   ├── main.go                     －－程序入口
    │   ├── README.md                   －－说明文件
    │   ├── &hellip;..
</pre></p>

<p>####编译:
<pre>
 #!/usr/bin/env bash
APP_NAME=&ldquo;code&rdquo;
echo &ldquo;begin build ${APP_NAME}:\n&rdquo;
go build -o ${APP_NAME}./src/${APP_NAME}/
echo &ldquo;strip ${APP_NAME}:\n&rdquo;
strip ${APP_NAME}
</pre></p>

<p>####部署到服务器:
<pre>
#!/usr/bin/env bash
echo &ldquo;begin sync to 10:\n&rdquo;
scp ${APP_NAME} zengbo@192.168.80.10:/var/www/backend/Go/${APP_NAME}/${APP_NAME}_tmp
if [ ${更新配置文件} -gt 0 ]
echo &ldquo;updata config.toml\n&rdquo;
scp ./data/conf/config.toml zengbo@192.168.80.10:/var/www/backend/Go/${APP_NAME}/config.toml_tmp
then
fi
echo &ldquo;ok\n&rdquo;
</pre></p>

<p>####停止正在运行的服务:
<pre>
#!/bin/bash</p>

<h1 id="停止服务shell:81d141d7a260742581a285f0fa97e1c1">停止服务shell</h1>

<p>#
APP_NAME=&ldquo;code&rdquo;
DIR=<code>/var/www/backend/Go/{$APP_NAME}</code>
cd $DIR
zero=0
echo &ldquo;begin reboot $APP_NAME program&rdquo;
#备份文件
file_name=<code>date +%Y%m%d_%H%M%S</code>
cp &ldquo;${APP_NAME}_tmp&rdquo;  &ldquo;bak/${APP_NAME}<em>bak</em>$file_name&rdquo;</p>

<p>#关闭正在运行的kjt
echo &ldquo;kill kjt&rdquo;
#kill
is_run=<code>ps axu|grep &quot;${APP_NAME}/${APP_NAME}&quot;|grep -v &quot;grep&quot;|awk '{print $2}'</code>
echo <code>ps axu|grep &quot;${APP_NAME}/${APP_NAME}&quot;|grep -v &quot;grep&quot;</code>
echo &ldquo;&mdash;-$is_run&mdash;&rdquo;
if [ ${#is_run[@]} -gt 0 ]
then
   #sh kill.sh &amp;
   <code>ps axu|grep &quot;${APP_NAME}/${APP_NAME}&quot;|grep -v &quot;grep&quot;|awk '{print $2}'|xargs kill -USR2</code>
   a=true
   while($a)
   do
       b=<code>ps axu|grep &quot;${APP_NAME}/${APP_NAME}&quot;|grep -v &quot;grep&quot;|awk '{print $2}'</code>
       if [ ${#b[@]} -eq $zero ]
           then
           a=false
        echo &ldquo;程序未运行&rdquo;
           else
               echo &ldquo;程序还在运行:,sleep2&rdquo;
               #增加2秒延迟
               /bin/sleep 2
       fi
   done
fi
echo &ldquo;success\n&rdquo;
</pre></p>

<p>####升级到最新部署的服务:
<pre>
#!/bin/bash
#移动文件
echo &ldquo;move file&rdquo;
mv &ldquo;bin/${APP_NAME}&rdquo; &ldquo;bin/${APP_NAME}.v0.1.1&rdquo;
mv &ldquo;${APP_NAME}_tmp&rdquo;  &ldquo;bin/${APP_NAME}&rdquo;
if [ ${更新配置文件} -gt 0 ]
then
echo &ldquo;updata config.toml\n&rdquo;
mv &ldquo;data/config/config.tomk&rdquo; &ldquo;data/config/config.tomk.v0.1.1&rdquo;
mv &ldquo;config.toml&rdquo;  &ldquo;data/config/config.tomk&rdquo;
echo &ldquo;ok\n&rdquo;
fi
</pre></p>

<p>####启动服务器上的服务:
<pre>
#!/bin/bash
#启动程序
echo &ldquo;run program&rdquo;
/var/www/backend/Go/${APP_NAME}/${APP_NAME} -c=&ldquo;/var/www/backend/Go/${APP_NAME}/data/conf/config.toml&rdquo; -d=true
echo &ldquo;OK!&rdquo;
</pre></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84golang%E4%BB%A3%E7%A0%81/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>计算内网IP的函数，内网IP为10.xx,172.xx,192.xx
toolkits/net/ip.go</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E4%B8%8D%E7%9F%A5%E9%81%93%E7%AE%97%E5%95%A5%E5%91%A2/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>当你准备演讲的时候，永远在桌子上放一瓶水。当你突然想不起来该说啥的时候，喝口水。听众不会感到任何异常的。</p>

<p>怀疑有人在跟踪你的车？那就来四个右转弯吧！这样，你的行驶路线可以形成一个圈。如果那个家伙还在，那他肯定在跟踪你。
如果你害怕有人会偷走你的蓝色钢笔，就给它安上一个红色的笔帽，因为没有人会偷一支红色的钢笔的。
如果你在公众场合被发现做了一件令人尴尬的事情，没关系，就说你在玩“真心话大冒险”。
15分钟的大笑，等同于30分钟的仰卧起坐。
在商店里，最便宜的东西不是在最上面的货架，就是在最下面的货架，而不会在眼睛的水平线上。</p>

<p>当你保存你的ppt时，用后缀.pps或.ppsx，那样的话，打开时会直接进入幻灯片播放模式。不仅节省时间，还看起来十分专业。</p>

<p>这更像是一条忠告：晚上，请把你的汽车钥匙放在床边。如果你听到房外有喧闹声，或者有人试图有人进入你的房间，马上按下你汽车的报警按钮。警报会响起，直到你关闭按钮或者汽车没电。当汽车警报响起时，如果有人尝试闯入你的房间，他绝对不敢逗留，因为过不了多久，大部分邻居都会出来看到底发生了什么。有时候，这个小技巧会拯救一条生命，或者一个潜在的性犯罪。</p>

<p>在你孩子还小的时候，给他们创建一个email的账号，坚持给那个账号发送图片和任何有价值的东西。等他们长大后 ，告诉他们email账号的密码，他们一定会很喜欢的。</p>

<p>上youtube网站时，在地址栏：</p>

<pre><code>把“youtube”换成“listentoyoutube”，可以下载视频的音频；
把“youtube”换成“ssyoutube”，可以下载任意图像质量的视频；
把“youtube”换成“listenonrepeat”，可以自动重放视频；
把“youtube”换成“youtubeskip”，你将不会看到广告
</code></pre>

<p>建立和保持人与人之间的关系。这是生存之道。</p>

<pre><code>照镜子，观察自己的肢体语言。
感受自己演讲时的声音和频率。
回想其他人说过的话。
仔细聆听别人的世界的模型，然后，在你答复他们之前，在你自己的脑海里建立起他们的模型。
</code></pre>

<p>每天和1-5个不同的人练习1分钟。
一个月之后，你的社交技巧将会如火箭般提升。</p>

<p>人做事情，都需要有个反馈，反馈的周期越久，感觉上就越困难。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%AD%89/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>组件  表可被复用
算法  编程的配方，高级形式的复用
模式  编程的模板，高级形式的复用
库    封装好的，避免重复造轮子</p>

<p>生活中的类比</p>

<p>洗碗:
    算法：配方,洗洁精、热水、丝瓜
    模式：模板，法式洗碗、花式洗碗、孙氏洗碗
做饭
    算法：配方, 秘方 比如什么秘制调料xxx等,又比如海底捞调料
    模式：模板，川菜、东北菜、粤菜 做菜的调料顺序都不同</p>

<p>写程序好的人，做饭会好吃么. 或者说怎样成为一个好的程序员</p>

<p>优秀的程序员，，工具箱，组件｛探索式学习，根据需要学习｝</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E6%80%9D%E8%80%83-%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E4%BA%8E%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>问题：
创业公司为什么不直接架构一个足够牛逼的系统</p>

<p>为啥人生下来啥都不知道，而不是生下来就已经知道绝大部分事情？</p>

<p>因为环境一直在演变
可以更快的适应环境
卸下一些包袱，（旧有的知识）</p>

<p>, 一旦我们fix一些知识后，就很难再接受新的</p>

<p>就像架构一样，程序架构是一个演变,
人的成长是人类不断进步的基础。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E6%91%98%E6%8A%84/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>营销是作为思维的存在，而非具体学科
对的，大多数真谛，就是如此：你编出一句听上去很像样子很简洁似乎概括了一切但其实终究只是以偏概全以便满足他人懒惰和虚荣心的玩意。
维特根斯坦说过，一切已有的哲学问题最后都是语言问题。
禅宗一向认为，事情就是事情本身，不是语言能描述的。
夏虫不能语冰：冰虽然是种合理的存在，但是夏天的虫子无论如何也会觉得不可思议，人也一样。</p>

<p>设计是一种艺术，而不是一种技术。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E7%94%9F%E6%B4%BB%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>问题：
    工作中付出与收获不成正比</p>

<p>原因：
    自己造轮子</p>

<p>结果：
    开发进度慢,累，费力不讨好，吃力</p>

<p>解决方案：
    学会用轮子，用好工具，有自己的工具箱</p>

<p>问题：
    逆鳞遭到碰触.</p>

<p>原因：
   业务侵入数据结构－ 数据结构由产品定。</p>

<p>结果：
    钻入牛角尖，感觉碰到逆鳞了。</p>

<p>解决方案：
    换个角度想问题，把数据库当作是接口.</p>

<p>问题：
    数据结构、算法，英文 不好</p>

<p>原因：
     大脑很懒惰，有些事情会被[大脑(原始脑)催眠]忽略掉.</p>

<p>结果：<br />
    明显的弱点[短板]被忽视很多年</p>

<p>解决方案：
    时常反省[每日三省吾身],快速补回来</p>

<p>问题：</p>

<p>原因：</p>

<p>结果：</p>

<p>解决方案：</p>

<p>问题：</p>

<p>原因：</p>

<p>结果：</p>

<p>解决方案：</p>

<p>问题：</p>

<p>原因：</p>

<p>结果：</p>

<p>解决方案：</p>

<p>问题：</p>

<p>原因：</p>

<p>结果：</p>

<p>解决方案：</p>

<p>问题：</p>

<p>原因：</p>

<p>结果：</p>

<p>解决方案：</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%B7%E7%9F%A5%E8%AF%86/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    <p>//
// 内网为啥是10,172,192开头?
// @ date 2016-03-31 17:04:43
// @ author simonsun
//
REC 1918留出了3块IP地址空间（1个A类地址段，16个B类地址段，256个C类地址段）作为私有的内部使用的地址。在这个范围内的IP地址不能被路由到Internet骨干网上；Internet路由器将丢弃该私有地址。</p>

<p>IP地址类别 RPC 1918内部地址范围
A类 10.0.0.0到10.255.255.255
B类 172.16.0.0到172.31.255.255
C类 192.168.0.0到192.168.255.255</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/%E8%B0%88%E8%B0%88%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%94%A8%E5%8A%9B%E8%BF%87%E7%8C%9B/">
        
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<h1 id="学习肯定是有方法的:2df8b085b01aad90c70a8c1c6d63cdb3">学习肯定是有方法的</h1>

<p>用力过猛[因] 导致  进度中断［果］</p>

<p>成长过慢[因] 导致 无反馈［果］ 导致中断</p>

<p>迅速提高(有反馈) ［因］ 导致有动力继续［果］ －》迅速提高－如此反复，成良性循环</p>

<p>&ndash;
反馈 ＝ 人类大脑机制，必须有反馈才会继续</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-beego-use/">
        BeeGo初探
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<h2 id="写在最前:85665b9a786fe827d0056a80c9c2d556">写在最前</h2>

<p>框架是对底层的封装，在使用golang之前一直都是做PHP开发，而PHP的框架很多像CI、YII、PhalconPHP等，当然自己也尝试着写了一下框架。在开始使用golang的时候为了了解底层也就没有使用框架。<code>本次了解beego是想学习下beego的代码</code>，顺便完善下自己的框架。<br />
作者花了一天时间去看文档以及代码，免不了有些细节不够了解。</p>

<p><br>
在最开始学习golang时就是看astaxie的书，也是那个时候知道的BeeGo。BeeGo是重量级的Go框架,github上标星快6k了。其优点自不必说。以下是我查看文档、代码中遇到的问题和疑惑。</p>

<h2 id="文档相关:85665b9a786fe827d0056a80c9c2d556">文档相关</h2>

<ul>
<li>beego集成了脚手架,通过new、run等实现快速开发,这个很赞<br /></li>
<li>beego内部封装了路由、控制器、模块、视图等mvc功能<br /></li>
<li>参数配置：这个不是很好用和我最初使用的方法一致，个人觉得配置最好用的应该是反射放到struct中，这样用起来才爽.<br /></li>
<li>获取参数：还是有些欠缺应该可以格式化全部(大部分)类型，而且返回值最好一个，直接解析到struct这个很赞<br /></li>
<li>数据绑定：Bind这个有点意思，特意查看了代码。代码很赞!值得参考.<br /></li>
<li>日志：日志可以输出到各种类型，很屌的样子，但是看文档中没有说明多文件存储，不能处理复杂业务，更不要说并发日志的处理了。<br /></li>
<li>模块－数据库操作，关于orm只用过gorm，单看API感觉比gorm好用,比gorm更多实用的封装，少了一些不好理解的东西<br /></li>
</ul>

<h2 id="代码相关:85665b9a786fe827d0056a80c9c2d556">代码相关</h2>

<p>config包，包里包含ini、json、xml、yaml等格式。关于配置这块我自己写过也用过其他人的，对比下来ini说实话将近400行代码有点啰嗦,推荐这个屌炸天的<code>github.com/go-ini/ini</code> 反射到struct超好用
cache包是对cache的封装，底层都是用第三方库，自不必多说,其中文件、内存缓存是直接写的，想写简单缓存的可以参考
httplib包是封装http请求，之前都是直接调http请求，这个是封装一下，调用方便。
logs包为多输出，这个值得借鉴</p>

<p>BeeGo是很好的一个框架，但是由于工作原因（后端服务，属于底层很多功能用不到又对性能要求比较高）无法使用。总的来说BeeGo不管用来学习还是作为框架来使用都是一个很好的选择。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/golang-code-source/">
        Golang 源码初探
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<h1 id="主要是跟着雨痕的文章一起研究的:267e5e576bf58833f83b1baa2ec0c5a3">主要是跟着雨痕的文章一起研究的</h1>

<h2 id="初始化:267e5e576bf58833f83b1baa2ec0c5a3">初始化</h2>

<p>初始化cpu： 源代码/runtime/os1_[所属环境].go ,通过getproccount函数调用不同底层的命令sysctl[mac]、sched_getaffinity[linux]<br />
设置进程数：源代码/runtime/proc1.go,通过procresize函数设置P的数量，1.3的时候比较暴力，似乎是cpu的倍数，特意查看了1.3源代码，是c写的。也都是调用系统底层命令。<br />
调用runtime.main:栈大小设置：64位1GB，32位250MB。</p>

<h2 id="内存管理:267e5e576bf58833f83b1baa2ec0c5a3">内存管理：</h2>

<p>malloc相关文件，
runtime/debug.FreeOSMemory 函数主动释放内存
除用 GODEBUG=&ldquo;gctrace=1&rdquo; 输出垃圾回收状态信息外,某些时候我们还需要自行获取内 存相关统计数据</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/architecture_how_to_use_beanstalk/">
        beanstalk使用介绍
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<h3 id="使用beanstalk也有二年了-之前对项目的beanstalk进行封装-php版本-golang两个版本-这里纪录一个日志权当说明文档来用了-div:1b0a41cc7d2fc25b18368e05c17b19c8">使用beanstalk也有二年了，之前对项目的beanstalk进行封装(php版本、GoLang两个版本)，这里纪录一个日志权当说明文档来用了</div></h3>

<h4 id="beanstalk功能描述:1b0a41cc7d2fc25b18368e05c17b19c8">beanstalk功能描述：</h4>

<p>beanstalk是一个异步的队列服务，目标是把复杂、耗时的任务放到后端去执行。提升前端响应时间。确切的说这里说的前端、后端 就是beanstalk的producer-consumer，一个负责生产，一个负责消费</p>

<h4 id="使用中发现的优缺点:1b0a41cc7d2fc25b18368e05c17b19c8">使用中发现的优缺点：</h4>

<ul>
<li>对于小的队列应用场景，使用beanstalk可以很方便快速的使用</li>
<li>不支持分布式</li>

<li><p>数据只有一份</p>

<h4 id="使用中未解决的问题:1b0a41cc7d2fc25b18368e05c17b19c8">使用中未解决的问题：</h4></li>

<li><p>发现beanstalk在使用中，在量稍微大一些的时候，经常假死：“有任务，但是取不到任务” 这个问题在GoLang、PHP中均存在</p></li>
</ul>

<h4 id="业务实例:1b0a41cc7d2fc25b18368e05c17b19c8">业务实例：</h4>

<ul>
<li>比如发邮件、短信等。可以直接丢入队列，然后服务端去依次发送</li>
<li>比如电商中的业务、行为分析等操作</li>
</ul>

<h4 id="具体使用方式:1b0a41cc7d2fc25b18368e05c17b19c8">具体使用方式：</h4>

<p>一个任务的典型生命流程很简单：
<pre class="EnlighterJSRAW" data-enlighter-language="null">
put （丢任务，生产者）  reserve（取任务，消费者）        delete（删除）
-&gt; [READY]beanstalk的状态-&gt; [RESERVED]beanstalk的状态—&gt; 生命周期完成
</pre>
    producer中创建任务，put后producer生命周期就结束了
    <br>
    consumer负责干活。一般取出任务后删除即可。取出任务之前是ready状态。取出任务后就reserve状态。删除后任务就清掉了。</p>

<h4 id="完整的生命周期:1b0a41cc7d2fc25b18368e05c17b19c8">完整的生命周期:</h4>

<p><a href="/wp-content/uploads/2015/05/0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A.png"><img src="http://dev.blog.simonsun.net/wp-content/uploads/2015/05/0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A.png" alt="0DE6ACB1-70AB-412B-A3EB-AC8520B51D9A" /></a>
{{ % img src=&ldquo;/upload/beanstalk_life.png&rdquo; alt=&ldquo;beanstalk完整的生命周期&rdquo; %}}</p>

<p>Beanstalkd中完整的任务的生命周期。一个job有READY, RESERVED, DELAYED, BURIED四种状态。
<br>
当producer直接put一个job时，job就处于READY状态，等待consumer来处理，如果选择延迟 put，job就先到DELAYED状态，等待时间过后才迁移到READY状态。
<br>
<code>consumer</code>获取了当前READY的job后，该job的状态就迁移 到RESERVED，这样其他的consumer就不能再操作该job。
<br>
当consumer完成该job后，可以选择delete, release或者bury操作;
<br>
delete之后，job从系统消亡，之后不能再获取;
<br>
release操作可以重新把该job状态迁移回READY(也 可以延迟该状态迁移操作)，使其他的consumer可以继续获取和执行该job;
<br>
有意思的是bury操作，可以把该job休眠，等到需要的时候，再将休 眠的job kick回READY状态，也可以delete BURIED状态的job。
<br>
正是有这些有趣的操作和状态，才可以基于此做出很多意思的应用，比如要实现一个循环队列，就可以将RESERVED状态的 job休眠掉，等没有READY状态的job时再将BURIED状态的job一次性kick回READY状态。</p>

<h4 id="任务的状态:1b0a41cc7d2fc25b18368e05c17b19c8">任务的状态：</h4>

<ul>
<li>ready     等待状态，任务在等待consumer执行</li>
<li>reserved     任务准备状态，当任务从tube中取出来（包括准备取出来）时，这个任务就是reserved状态，其他consumer将取不到此任务</li>
<li>delayed      延时状态，任务在指定时间之后才会变为ready状态</li>
<li>buried       等待kick，通常是任务失败为此状态</li>
</ul>

<h4 id="参数说明:1b0a41cc7d2fc25b18368e05c17b19c8">参数说明：</h4>

<ul>
<li>pri &#8211; priority(优先级) － 支持0到2**32的优先级，值越小，优先级越高，默认优先级为1024。</li>
<li>ttr &#8211; time to run(任务执行时间) － 允许consumer执行这个任务的时间</li>
<li>delay － 定时执行的时间，秒为单位</li>
</ul>

<h4 id="命令列表:1b0a41cc7d2fc25b18368e05c17b19c8">命令列表：</h4>

<p>生产者使用命令
<br></p>

<p>put
写入一个任务
     $ put <pri> <delay> <ttr> <bytes>\r\n
<data>\r\n</p>

<h4 id="other-commands:1b0a41cc7d2fc25b18368e05c17b19c8">－－Other Commands－－</h4>

<ul>
<li>peek</li>
<li>kick</li>
<li>kick-job</li>
<li>stats-job</li>
<li>stats-tube</li>
<li>stats</li>
<li>list-tubes</li>
<li>list-tube-used</li>
<li>list-tubes-watched</li>
<li>quit</li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/logv3/">
        golang日志系统架构设计
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<p>#[名言] 不断的重构，模块会越来越壮大，功能会越来越多，代码会复杂，这时候开始重构。</p>

<h3 id="为啥鞋日志包:7fd877a2562cbb7976f27484b36083fa">为啥鞋日志包</h3>

<p>日志是debug不可或缺的模块，当出现问题时可以追踪问题、查看异常原因。作为后端服务，需要能够回溯问题并告知使用服务的同学问题出在哪里。
目前还未发现比较健壮、并且适用本地服务的开源日志包，所以只能自己动手。</p>

<h3 id="日志包的使用臆测:7fd877a2562cbb7976f27484b36083fa">日志包的使用臆测</h3>

<p>可以不初始化 - 单元测试、无需日志的时候，可以直接使用。
可以支持并发日志。－日志按块写入，根据pkid查看整个生命周期
可以不同端输出。－ 日志可以同时写入文件、控制台
可以多文件存储。－ 日志根据业务[组]写入不同的文件中</p>

<p>我们会收到使用服务的同学的各种问题</p>

<h3 id="v3版本日志功能:7fd877a2562cbb7976f27484b36083fa">v3版本日志功能：</h3>

<ul>
<li>支持并发写入

<ul>
<li>块级写入</li>
<li>原子操作ID</li>
</ul></li>
<li>多分组输出

<ul>
<li>按名字分别写入</li>
</ul></li>
<li>多种输出方式

<ul>
<li>console - stdout</li>
<li>file</li>
<li>queue 队列输出</li>
</ul></li>
<li>打印文件名，行号</li>
</ul>

<h3 id="日志与内置log-beego-log的区别:7fd877a2562cbb7976f27484b36083fa">日志与内置log、BeeGo log的区别</h3>

<p>使用为了简单，快速开发，以及更好的兼容本地服务。
log可以多文件存储，但是多种输出方式得封装
BeeGo可以多种输出方式，但是文件只能一个</p>

<p>使用方式[简单版]:<br />
var log *logv3.Logger = logv3.NewLog(nil)
log.Debug(&ldquo;log debug&rdquo;,1,2,&ldquo;content&rdquo;)
log.Error(&ldquo;faild&rdquo;)
输出到console：
[2015-10-22 11:33:22,debug] log debug 1 2 content
[2015-10-22 11:33:22,info] faild
[2015-10-22 11:33:22,debug] faild
[2015-10-22 11:33:22,error] faild</p>

<p>使用方式:<br />
//创建日志配置
var log_struct *logv3.LogStruct = &amp;logv3.LogStruct{
    OpenFileLine : false,
    FileStruct:&amp;logv3.FileStruct{
        LogPath:&ldquo;/tmp/testlog/&rdquo;,
        LogName:&ldquo;log&rdquo;,
    },
    ConsoleStruct:&amp;logv3.ConsoleStruct{</p>

<pre><code>},
</code></pre>

<p>}
//创建一个logger
var log *logv3.Logger = logv3.NewLog(log_struct)
//创建一个分组
var group1 *logv3.Group  = log.NewGroup(&ldquo;group_name1&rdquo;)
group1.Debug(&ldquo;log_debug1&rdquo;)
//创建一个分组
var group2 *logv3.Group  = log.NewGroup(&ldquo;group_name2&rdquo;)
group2.Debug(&ldquo;log_debug2&rdquo;)
//原log可以继续使用
log.Debug(&ldquo;log_debug0&rdquo;)</p>

<p>会输出到console，并且写入文件
[2015-10-22 11:33:22,0,debug] log_debug1
[2015-10-22 11:33:22,0,debug] log_debug2
[2015-10-22 11:33:22,0,debug] log_debug0</p>

<p>文件：/tmp/testlog/log-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,0,debug] log_debug0</p>

<p>文件：/tmp/testlog/group_name1-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,1,debug] log_debug1</p>

<p>文件：/tmp/testlog/group_name2-debug-2015-10-22.log
内容：
[2015-10-22 11:33:22,2,debug] log_debug2</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://blog.simonsun.net/arithmetic-binary-search/">
        算法 － 二分查找(Binary Search)
      </a>
    </h1>

    <span class="post-date">0001-01-01</span>



    

<h2 id="前言:5ec26f00f35df1515016e8c39c803553">前言：</h2>

<p>算法时间复杂度按优劣排差不多集中在：</p>

<p>O(1), O(log n), O(n), O(n log n), O(n2), O(nk), O(2n)</p>

<p>到目前位置，似乎我学到的算法中，时间复杂度是O(log n),好像就数二分查找法，其他的诸如排序算法都是 O(n log n)或者O(n2)。但是也正是因为有二分的 O(log n), 才让很多 O(n2)缩减到只要O(n log n)。</p>

<p>作用：</p>

<p>二分查找法主要是解决在“一堆数中找出指定的数”这类问题。</p>

<p>条件：</p>

<p>想要应用二分查找法，这“一堆数”必须有一下特征：</p>

<p>存储在数组中</p>

<p>有序排列</p>

<p>搜索值必须在数组中</p>

<p>原理：</p>

<p>二分查找算法就是不断将数组进行对半分割，每次拿中间元素和goal进行比较。</p>

<p>代码示例：</p>

<p>php:</p>

<pre><code class="php">
&lt;?php
$array = array(1,3,4,6,6,6,7,8,9,10);

$search = 9;

$res = binarySearch($array,$search);

var_dump($res);

/**

* 二分查找(binary search)

* 返回搜索值在数组中的位置，如搜索不到返回false

*/

function binarySearch($array ,$search) {

$high = count($array) - 1;

$low = 0 ;

//搜索值不存在于数组中则搜索不到

if($search &lt; $array[$low] || $search &gt; $array[$high]){

return false ;

}

while ($low &lt;= $high){

//取中间位置

$mid = floor($low + ($high - $low)/2) ;

if($array[$mid]&gt;$search){//如果搜索值小于当前中间位置，则设置最大边界为当前中间位置－1

$high = $mid - 1 ;

}else if($array[$mid]&lt;$search){//如果搜索值大于当前中间位置，则设置最小边界为当前边界＋1

$low  = $mid + 1 ;

}else{

//不大于也不小于就是等于了

return $mid ;

}

}

return false ;

}
?&lt;
</code></pre>

<p>golang:</p>

<pre><code class="go">
package main

import (

"errors"

"fmt"

)

func main() {

var array []int = []int{1, 3, 4, 6, 6, 6, 7, 8, 9, 10}

var search int = 9

var pos int

var err error

pos, err = binarySearch(array, search)

fmt.Println(pos)

fmt.Println(err)

}

func binarySearch(array []int, search int) (pos int, err error) {

var low int = 0

var high int = len(array) - 1

var middle int

for low &lt;= high {

//取中间位置

middle = low + (high-low)/2

//如果搜索值小于当前中间位置，则设置最大边界为当前中间位置－1

if array[middle] &gt; search {

high = middle - 1

continue

}

//如果搜索值大于当前中间位置，则设置最小边界为当前边界＋1

if array[middle] &lt; search {

high = middle - 1

continue

}

//如果搜索值大于当前中间位置，则设置最小边界为当前边界＋1

if array[middle] &lt; search {

low = middle + 1

continue

}

//不大于也不小于就是等于了

if array[middle] == search {

return middle, nil

}

}

return -1, errors.New("not find")

}
</code></pre>

<h2 id="缺陷:5ec26f00f35df1515016e8c39c803553">缺陷：</h2>

<p>二分查找法的O(log n)让它成为十分高效的算法。不过它的缺陷却也是那么明显的。就在它的限定之上：</p>

<p>必须有序，我们很难保证我们的数组都是有序的。当然可以在构建数组的时候进行排序，可是又落到了第二个瓶颈上：它必须是数组。</p>

<p>数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)。因而导致构建有序数组变成低效的事情。</p>

  </div>
  
</div>
</div>

  </body>
</html>
